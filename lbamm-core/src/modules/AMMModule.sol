//SPDX-License-Identifier: LicenseRef-PolyForm-Strict-1.0.0
pragma solidity 0.8.24;

import "../libraries/FeeHelper.sol";
import "../libraries/PoolDecoder.sol";
import "../libraries/LBAMMStorage.sol";

import "../interfaces/ILimitBreakAMM.sol";
import "../interfaces/ILimitBreakAMMPoolType.sol";
import "../interfaces/ILimitBreakAMMFlashloanCallback.sol";
import "../interfaces/ILimitBreakAMMTransferHandler.sol";
import "../interfaces/core/ILimitBreakAMMEvents.sol";
import "../interfaces/hooks/ILimitBreakAMMLiquidityHook.sol";
import "../interfaces/hooks/ILimitBreakAMMPoolHook.sol";
import "../interfaces/hooks/ILimitBreakAMMTokenHook.sol";

import "@limitbreak/tm-core-lib/src/token/erc20/IERC20.sol";
import "@limitbreak/tm-core-lib/src/token/erc20/utils/SafeERC20.sol";
import "@limitbreak/tm-core-lib/src/utils/cryptography/EfficientHash.sol";
import "@limitbreak/tm-core-lib/src/utils/misc/SafeCast.sol";
import "@limitbreak/tm-core-lib/src/utils/security/TstorishReentrancyGuardWithFlags.sol";
import "@limitbreak/tm-core-lib/src/licenses/LicenseRef-PolyForm-Strict-1.0.0.sol";

import "@limitbreak/wrapped-native/interfaces/IWrappedNativeExtended.sol";

/**
 * @title AMMModule
 * @author Limit Break, Inc.
 * @notice Core AMM implementation providing pool creation, liquidity management, swaps, and flash loans.
 *
 * @dev    This contract implements the main AMM functionality using Diamond storage patterns and a modular
 *         architecture. It supports pluggable pool types, a comprehensive three-tier hook system, and
 *         handles native token integration through wrapped native contracts.
 *
 * @dev    **Key Features:**
 *         - Pluggable pool type architecture supporting multiple AMM formulas
 *         - Three-tier hook system (token, pool, and liquidity hooks)
 *         - Multi-hop swap routing with configurable fees
 *         - Flash loan functionality with token-determined fees
 *         - Direct token swaps bypassing AMM pools
 *         - Native token support via wrapped native integration
 *         - Comprehensive fee structure with protocol revenue sharing
 */
contract AMMModule is TstorishReentrancyGuardWithFlags, ILimitBreakAMMEvents {
    using SafeCast for uint256;

    /// @dev The wrapped native token contract used for ETH handling on this chain
    IWrappedNativeExtended immutable wrappedNative;

    constructor(
        address wrappedNative_
    ) {
        wrappedNative = IWrappedNativeExtended(wrappedNative_);
    }

    ///////////////////////////////////////////////////////
    //                   POOL CREATION                   //
    ///////////////////////////////////////////////////////

    /**
     * @dev Creates a new pool with the specified parameters and executes all relevant creation hooks.
     *
     * @dev Throws when either token contains no code.
     *      Throws when pool fee exceeds 100% (unless it's a dynamic fee pool).
     *      Throws when pool fee is dynamic but no pool hook is provided.
     *      Throws when pool type address has invalid format.
     *      Throws when attempting to pair identical tokens.
     *      Throws when pool already exists.
     *      Throws when the pool type contract returns an invalid pool ID (poolType or fee do not match provided details).
     *      Throws when any pool hook validations fail.
     *
     *      This function handles the complete pool creation process including parameter validation, token ordering,
     *      pool ID generation through delegation to the pool type contract, hook execution, and initialization marking.
     *      The actual pool state creation is delegated to the specified pool type contract. Pool hooks are enforced
     *      if the token settings require them to be.
     *
     *      <h4>Postconditions:</h4>
     *      1. Tokens have been ordered with smaller address as token0 if necessary.
     *      2. Pool ID has been generated by the pool type contract.
     *      3. All applicable pool creation hooks have been executed.
     *      4. Pool has been marked as initialized in storage.
     *      5. PoolCreated event has been emitted.
     *
     * @param  details        Complete pool creation parameters including tokens, fees, and pool type.
     * @param  token0HookData Hook data for the first token's validation.
     * @param  token1HookData Hook data for the second token's validation.
     * @param  poolHookData   Hook data for pool-level validation.
     * @return poolId         The unique identifier for the created pool generated by the pool type contract.
     */
    function _createPool(
        PoolCreationDetails memory details,
        bytes calldata token0HookData,
        bytes calldata token1HookData,
        bytes calldata poolHookData
    ) internal returns (bytes32 poolId) {
        //@note this are used to check passed address are deployed contract not externally owned accounts
        _requireAddressHasCode(details.token0);
        _requireAddressHasCode(details.token1);
        
        if (details.fee > MAX_BPS) { 
            if (details.fee != DYNAMIC_POOL_FEE_BPS) {
                revert LBAMM__PoolFeeMustBeLessThan100Percent();
            } else {
                if (details.poolHook == address(0)) {
                    revert LBAMM__InvalidPoolFeeHook();
                }
            }
        }

        if (uint160(details.poolType) & POOL_TYPE_ADDRESS_MASK != 0) {
            revert LBAMM__InvalidPoolType();
        }

        if (details.token0 == details.token1) {
            revert LBAMM__CannotPairIdenticalTokens();
        }

        if (details.token0 > details.token1) {
            (details.token0, details.token1) = (details.token1, details.token0);
            (token0HookData, token1HookData) = (token1HookData, token0HookData);
        }
        // note this is dynamic type of calling which is directly depends on the 
        // detail.poolType address. Using this it calls the function createPool
        poolId = ILimitBreakAMMPoolType(details.poolType).createPool(details);

        if (
            PoolDecoder.getPoolType(poolId) != details.poolType ||
            PoolDecoder.getPoolFee(poolId) != details.fee
        ) {
            revert LBAMM__InvalidPoolId();
        }

        if (Storage.appStorage().poolInitialized[poolId]) {
            revert LBAMM__PoolAlreadyExists();
        }

        Storage.appStorage().poolInitialized[poolId] = true;
        Storage.appStorage().pools[poolId] = PoolState({
            token0: details.token0,
            token1: details.token1,
            feeBalance0: 0,
            feeBalance1: 0,
            reserve0: 0,
            reserve1: 0,
            poolHook: details.poolHook
        });

        _executePoolCreationHooks(poolId, details, token0HookData, token1HookData, poolHookData);

        emit PoolCreated(details.poolType, details.token0, details.token1, poolId, details.poolHook);
    }

    /**
     * @dev Validates that the provided address contains deployed code.
     *
     * @dev Throws when the address contains no code.
     *
     *      This function ensures that token addresses used in pool creation are actual deployed
     *      contracts rather than externally owned accounts. It checks the code length at the
     *      specified address to validate contract deployment.
     *
     * @param tokenAddress The address to validate for deployed contract code.
     */
    function _requireAddressHasCode(address tokenAddress) internal view {
       if (tokenAddress.code.length == 0) {
           revert LBAMM__PoolCreationWithNoCodeAtToken();
       }
    }

    /**
     * @dev Executes all applicable pool creation hooks for tokens and pools.
     *
     * @dev Throws when any token hook validation fails.
     *      Throws when pool hook validation fails.
     *
     *      This function coordinates the execution of pool creation validation hooks across different levels:
     *      token-level hooks for both tokens and pool-level hooks when applicable. Hook execution depends
     *      on the token settings and pool configuration. Hooks are executed in order: token0, token1, then pool.
     *
     *      <h4>Postconditions:</h4>
     *      1. Token0 pool creation hook executed if enabled in token settings.
     *      2. Token1 pool creation hook executed if enabled in token settings.
     *      3. Pool creation hook executed if pool hook address is non-zero.
     *      4. All hooks executed in sequence: token0, token1, pool.
     *
     * @param  poolId         The identifier of the pool to validate.
     * @param  details        The pool creation details containing all necessary parameters.
     * @param  token0HookData Additional data for token0's pool creation hook.
     * @param  token1HookData Additional data for token1's pool creation hook.
     * @param  poolHookData   Additional data for the pool's creation hook.
     */
    function _executePoolCreationHooks(
        bytes32 poolId,
        PoolCreationDetails memory details,
        bytes calldata token0HookData,
        bytes calldata token1HookData,
        bytes calldata poolHookData
    ) internal {
        TokenSettings memory token0Settings = Storage.appStorage().tokenSettings[details.token0];
        TokenSettings memory token1Settings = Storage.appStorage().tokenSettings[details.token1];
        _executeTokenPoolCreationHook(poolId, true, details, token0Settings, token0HookData);
        _executeTokenPoolCreationHook(poolId, false, details, token1Settings, token1HookData);

        if (details.poolHook != address(0)) {
            _executePoolPoolCreationHook(poolId, details, poolHookData);
        }
    }

    /**
     * @dev Executes token-specific pool creation validation hook if enabled.
     *
     * @dev Throws when token hook validation fails.
     *      Throws when hook contract call reverts.
     *      Checks if the token has pool creation hooks enabled in its settings and executes the validation
     *      if required. The hook can reject pool creation by reverting or throwing validation errors.
     *
     * @param  poolId         The identifier of the pool to validate.
     * @param  hookForToken0  True if the call is for token0, false otherwise.
     * @param  details        The pool creation details for validation.
     * @param  tokenSettings  The token's configuration settings including hook flags.
     * @param  tokenHookData  Additional data to pass to the token's hook.
     */
    function _executeTokenPoolCreationHook(
        bytes32 poolId,
        bool hookForToken0,
        PoolCreationDetails memory details,
        TokenSettings memory tokenSettings,
        bytes calldata tokenHookData
    ) internal {
        if (_isFlagSet(tokenSettings.packedSettings, TOKEN_SETTINGS_POOL_CREATION_HOOK_FLAG)) {
            ILimitBreakAMMTokenHook(tokenSettings.tokenHook).validatePoolCreation(
                poolId, msg.sender, hookForToken0, details, tokenHookData
            );
        }
    }

    /**
     * @dev Executes pool-level pool creation validation hook.
     *
     * @dev Throws when pool hook validation fails.
     *      Throws when hook contract call reverts.
     *
     *      Calls the pool hook's validation function for pool creation. This is typically used for pools
     *      with dynamic pricing or fee structures that require additional validation logic.
     *
     * @param  poolId       The identifier of the pool to validate.
     * @param  details      The pool creation details for validation.
     * @param  poolHookData Additional data to pass to the pool's hook.
     */
    function _executePoolPoolCreationHook(
        bytes32 poolId,
        PoolCreationDetails memory details,
        bytes calldata poolHookData
    ) internal {
        ILimitBreakAMMPoolHook(details.poolHook).validatePoolCreation(
            poolId,
            msg.sender,
            details,
            poolHookData
        );
    }

    ///////////////////////////////////////////////////////
    //                   POSITION MGMT                   //
    ///////////////////////////////////////////////////////

    /**
     * @dev Collects accumulated fees from a liquidity position and distributes them to the provider.
     *
     * @dev Throws when the pool does not exist.
     *      Throws when pool type contract call reverts.
     *      Throws when fee balance underflow occurs during reduction.
     *      Throws when SafeCast conversion fails (fees exceed uint128 max).
     *      Throws when token debt storage causes overflow.
     *      Throws when any hook validation fails.
     *
     *      This function collects fees that have accumulated on a liquidity position by delegating to the
     *      pool type contract for fee calculation, reducing pool fee balances, distributing collected fees
     *      to the liquidity provider, and executing all applicable hook validations.
     *
     *      <h4>Developer Notes:</h4>
     *      - Negative amounts passed to distribution function indicate outbound transfers to provider
     *      - Failed token transfers are gracefully handled by storing amounts as debt
     *      - Hook execution follows strict order: token hooks, position hooks, then pool hooks
     *
     *      <h4>Postconditions:</h4>
     *      1. Pool fee balances reduced by collected amounts
     *      2. Collected fees distributed to liquidity provider
     *      3. Token hooks executed for both tokens if enabled in token settings
     *      4. Position hook executed if liquidity hook address is non-zero
     *      5. Pool hook executed if pool hook address is non-zero
     *      6. LiquidityContext populated with caller, provider, and token information
     *      7. Failed token transfers stored as debt rather than causing reverts
     *
     * @param  liquidityParams         Parameters for fee collection including pool ID and pool-specific data.
     * @param  liquidityHooksExtraData Hook data for token, position, and pool hook validations.
     * @return fees0                   Amount of token0 fees collected and distributed to provider.
     * @return fees1                   Amount of token1 fees collected and distributed to provider.
     */
    function _positionCollectFees(
        LiquidityCollectFeesParams calldata liquidityParams,
        LiquidityHooksExtraData calldata liquidityHooksExtraData
    ) internal returns (uint256 fees0, uint256 fees1) {
        _requirePoolIsCreated(liquidityParams.poolId);
        
        PoolState storage ptrPoolState = Storage.appStorage().pools[liquidityParams.poolId];

        LiquidityContext memory context;
        context.provider = msg.sender;
        context.token0 = ptrPoolState.token0;
        context.token1 = ptrPoolState.token1;

        bytes32 ammBasePositionId = EfficientHash.efficientHash(
            bytes32(uint256(uint160(context.provider))),
            bytes32(uint256(uint160(liquidityParams.liquidityHook))),
            liquidityParams.poolId
        );

        (
            context.positionId,
            fees0,
            fees1
        ) = ILimitBreakAMMPoolType(PoolDecoder.getPoolType(liquidityParams.poolId)).collectFees(
            liquidityParams.poolId,
            context.provider,
            ammBasePositionId,
            liquidityParams.poolParams
        );

        (uint256 hookFee0, uint256 hookFee1) = _executeLiquidityCollectFeesHooks(
            liquidityParams,
            context,
            fees0,
            fees1,
            ptrPoolState.poolHook,
            liquidityHooksExtraData
        );

        if (hookFee0 > liquidityParams.maxHookFee0 || hookFee1 > liquidityParams.maxHookFee1) {
            revert LBAMM__ExcessiveHookFees();
        }

        if (fees0 > 0) {
            ptrPoolState.feeBalance0 = _safeDecrementUint128(ptrPoolState.feeBalance0, fees0);
        }
        if (fees1 > 0) {
            ptrPoolState.feeBalance1 = _safeDecrementUint128(ptrPoolState.feeBalance1, fees1);
        }

        _distributeAndCollectLiquidityTokens(
            context.provider,
            context.token0,
            context.token1,
            -fees0.toInt256() + hookFee0.toInt256(),
            -fees1.toInt256() + hookFee1.toInt256()
        );

        emit FeesCollected(liquidityParams.poolId, context.provider, fees0, fees1);

        if (_queuedHookFeesByHookTransfers() > 0) {
            ILimitBreakAMM(address(this)).executeQueuedHookFeesByHookTransfers();
        }
    }

    /**
     * @dev Adds liquidity to a position by depositing tokens and collecting accumulated fees.
     *
     * @dev Throws when the pool does not exist.
     *      Throws when pool type contract call reverts.
     *      Throws when deposit amounts do not meet requirements.
     *      Throws when insufficient fee balance available for fee collection.
     *      Throws when token debt storage causes overflow.
     *      Throws when any hook validation fails.
     *
     *      Delegates liquidity addition to the pool type contract, updates pool state, handles
     *      token transfers for deposits and fee collection, and executes all applicable hooks.
     *
     *      <h4>Developer Notes:</h4>
     *      - Net token amounts are calculated as deposit plus hook fees minus pool fees collected
     *      - Failed token transfers are gracefully handled by storing amounts as debt
     *      - Hook execution follows strict order: token hooks, position hooks, then pool hooks
     *
     *      <h4>Postconditions:</h4>
     *      1. Deposit amounts validated against requirements
     *      2. Pool reserves increased by deposit amounts
     *      3. Pool fee balances reduced by fees collected
     *      4. Net token amounts collected from or distributed to provider
     *      5. All applicable hooks executed successfully
     *      6. Failed token transfers stored as debt rather than causing reverts
     *
     * @param  liquidityParams         Parameters for liquidity addition including pool ID and minimum amounts.
     * @param  liquidityHooksExtraData Hook data for token, position, and pool hook validations.
     * @return deposit0                Amount of token0 deposited into the pool.
     * @return deposit1                Amount of token1 deposited into the pool.
     * @return fees0                   Amount of token0 fees collected from the pool.
     * @return fees1                   Amount of token1 fees collected from the pool.
     */
    function _positionAddLiquidity(
        LiquidityModificationParams calldata liquidityParams,
        LiquidityHooksExtraData calldata liquidityHooksExtraData
    ) internal returns (uint256 deposit0, uint256 deposit1, uint256 fees0, uint256 fees1) {
        // note this check if the pool id is created or not
        _requirePoolIsCreated(liquidityParams.poolId);

        PoolState storage ptrPoolState = Storage.appStorage().pools[liquidityParams.poolId];

        LiquidityContext memory context;
        context.provider = msg.sender;
        context.token0 = ptrPoolState.token0;
        context.token1 = ptrPoolState.token1;

        bytes32 ammBasePositionId = EfficientHash.efficientHash(
            bytes32(uint256(uint160(context.provider))),
            bytes32(uint256(uint160(liquidityParams.liquidityHook))),
            liquidityParams.poolId
        );

        //  note This is where we are adding the liquidity to the pool either fized , dynamic  
        (
            context.positionId,
            deposit0,
            deposit1,
            fees0,
            fees1
        ) = ILimitBreakAMMPoolType(PoolDecoder.getPoolType(liquidityParams.poolId)).addLiquidity(
            liquidityParams.poolId,
            context.provider,
            ammBasePositionId,
            liquidityParams.poolParams
        );

        if (deposit0 < liquidityParams.minLiquidityAmount0 || deposit1 < liquidityParams.minLiquidityAmount1) {
            revert LBAMM__InsufficientLiquidityChange();
        }

        if (deposit0 > liquidityParams.maxLiquidityAmount0 || deposit1 > liquidityParams.maxLiquidityAmount1) {
            revert LBAMM__ExcessiveLiquidityChange();
        }

        (uint256 hookFee0, uint256 hookFee1) = _executeAddLiquidityHooks(
            liquidityParams,
            liquidityHooksExtraData,
            context,
            InternalLiquidityModificationCache({
                amount0: deposit0,
                amount1: deposit1,
                fees0: fees0,
                fees1: fees1
            }),
            ptrPoolState.poolHook
        );

        if (hookFee0 > liquidityParams.maxHookFee0 || hookFee1 > liquidityParams.maxHookFee1) {
            revert LBAMM__ExcessiveHookFees();
        }

        if (deposit0 > 0) {
            ptrPoolState.reserve0 = _safeIncrementUint128(ptrPoolState.reserve0, deposit0);
        }
        if (deposit1 > 0) {
            ptrPoolState.reserve1 = _safeIncrementUint128(ptrPoolState.reserve1, deposit1);
        }

        if (fees0 > 0) {
            ptrPoolState.feeBalance0 = _safeDecrementUint128(ptrPoolState.feeBalance0, fees0);
        }
        if (fees1 > 0) {
            ptrPoolState.feeBalance1 = _safeDecrementUint128(ptrPoolState.feeBalance1, fees1);
        }

        _distributeAndCollectLiquidityTokens(
            context.provider,
            context.token0,
            context.token1,
            deposit0.toInt256() - fees0.toInt256() + hookFee0.toInt256(),
            deposit1.toInt256() - fees1.toInt256() + hookFee1.toInt256()
        );

        emit LiquidityAdded(
            liquidityParams.poolId,
            context.provider,
            deposit0,
            deposit1,
            fees0,
            fees1
        );

        if (_queuedHookFeesByHookTransfers() > 0) {
            ILimitBreakAMM(address(this)).executeQueuedHookFeesByHookTransfers();
        }
    }

    /**
     * @dev Removes liquidity from a position by withdrawing tokens and collecting accumulated fees.
     *
     * @dev Throws when the pool does not exist.
     *      Throws when pool type contract call reverts.
     *      Throws when withdraw amounts do not meet requirements.
     *      Throws when reserve or fee balance underflow occurs during reduction.
     *      Throws when token debt storage causes overflow.
     *      Throws when any hook validation fails.
     *
     *      Delegates liquidity removal to the pool type contract, updates pool state by reducing
     *      reserves and fee balances, distributes withdrawn tokens and collected fees to the position owner,
     *      and executes all applicable hooks.
     *
     *      <h4>Developer Notes:</h4>
     *      - Hook execution follows strict order: token hooks, position hooks, then pool hooks
     *
     *      <h4>Postconditions:</h4>
     *      1. Withdraw amounts validated against requirements
     *      2. Pool state updated (reserves and fee balances reduced)
     *      3. Net token amounts distributed to position owner (withdraw + fees)
     *      4. All applicable hooks executed successfully
     *      5. Failed token transfers stored as debt rather than causing reverts
     *
     * @param  liquidityParams         Parameters for liquidity removal including pool ID and minimum amounts.
     * @param  liquidityHooksExtraData Hook data for token, position, and pool hook validations.
     * @return withdraw0               Amount of token0 withdrawn from the pool.
     * @return withdraw1               Amount of token1 withdrawn from the pool.
     * @return fees0                   Amount of token0 fees collected from the pool.
     * @return fees1                   Amount of token1 fees collected from the pool.
     */
    function _positionRemoveLiquidity(
        LiquidityModificationParams calldata liquidityParams,
        LiquidityHooksExtraData calldata liquidityHooksExtraData
    ) internal returns (uint256 withdraw0, uint256 withdraw1, uint256 fees0, uint256 fees1) {
        _requirePoolIsCreated(liquidityParams.poolId);

        PoolState storage ptrPoolState = Storage.appStorage().pools[liquidityParams.poolId];

        LiquidityContext memory context;
        context.provider = msg.sender;
        context.token0 = ptrPoolState.token0;
        context.token1 = ptrPoolState.token1;

        bytes32 ammBasePositionId = EfficientHash.efficientHash(
            bytes32(uint256(uint160(context.provider))),
            bytes32(uint256(uint160(liquidityParams.liquidityHook))),
            liquidityParams.poolId
        );

        (
            context.positionId,
            withdraw0,
            withdraw1,
            fees0,
            fees1
        ) = ILimitBreakAMMPoolType(PoolDecoder.getPoolType(liquidityParams.poolId)).removeLiquidity(
            liquidityParams.poolId,
            context.provider,
            ammBasePositionId,
            liquidityParams.poolParams
        );

        if (withdraw0 < liquidityParams.minLiquidityAmount0 || withdraw1 < liquidityParams.minLiquidityAmount1) {
            revert LBAMM__InsufficientLiquidityChange();
        }

        if (withdraw0 > liquidityParams.maxLiquidityAmount0 || withdraw1 > liquidityParams.maxLiquidityAmount1) {
            revert LBAMM__ExcessiveLiquidityChange();
        }

        (uint256 hookFee0, uint256 hookFee1) = _executeRemoveLiquidityHooks(
            liquidityParams,
            liquidityHooksExtraData,
            context,
            InternalLiquidityModificationCache({
                amount0: withdraw0,
                amount1: withdraw1,
                fees0: fees0,
                fees1: fees1
            }),
            ptrPoolState.poolHook
        );

        if (hookFee0 > liquidityParams.maxHookFee0 || hookFee1 > liquidityParams.maxHookFee1) {
            revert LBAMM__ExcessiveHookFees();
        }

        if (withdraw0 > 0) {
            ptrPoolState.reserve0 = _safeDecrementUint128(ptrPoolState.reserve0, withdraw0);
        }
        if (withdraw1 > 0) {
            ptrPoolState.reserve1 = _safeDecrementUint128(ptrPoolState.reserve1, withdraw1);
        }

        if (fees0 > 0) {
            ptrPoolState.feeBalance0 = _safeDecrementUint128(ptrPoolState.feeBalance0, fees0);
        }
        if (fees1 > 0) {
            ptrPoolState.feeBalance1 = _safeDecrementUint128(ptrPoolState.feeBalance1, fees1);
        }

        _distributeAndCollectLiquidityTokens(
            context.provider,
            context.token0,
            context.token1,
            -withdraw0.toInt256() - fees0.toInt256() + hookFee0.toInt256(),
            -withdraw1.toInt256() - fees1.toInt256() + hookFee1.toInt256()
        );

        emit LiquidityRemoved(
            liquidityParams.poolId,
            context.provider,
            withdraw0,
            withdraw1,
            fees0,
            fees1
        );

        if (_queuedHookFeesByHookTransfers() > 0) {
            ILimitBreakAMM(address(this)).executeQueuedHookFeesByHookTransfers();
        }
    }

    /**
     * @dev Executes all applicable hooks for liquidity fee collection operations.
     *
     * @dev Throws when any token hook validation fails.
     *      Throws when position hook validation fails.
     *      Throws when pool hook validation fails.
     *
     *      Coordinates the execution of fee collection validation hooks across all three tiers of the
     *      hook system. Retrieves token settings for both tokens and executes hooks in strict order:
     *      token0 hook, token1 hook, position hook, then pool hook. Each hook receives the complete
     *      fee collection context and can validate or reject the operation.
     *
     *      <h4>Developer Notes:</h4>
     *      - Hook execution is conditional based on settings and addresses
     *
     *      <h4>Postconditions:</h4>
     *      1. All applicable hooks executed successfully based on configuration
     *      2. Fee collection operation validated by all enabled hooks
     *
     * @param  liquidityParams         Parameters for fee collection including pool ID and pool-specific data.
     * @param  context                 Fee collection context with caller, provider, and token information.
     * @param  fees0                   Amount of token0 fees being collected.
     * @param  fees1                   Amount of token1 fees being collected.
     * @param  poolHook                Address of the pool hook contract.
     * @param  liquidityHooksExtraData Hook data for token, position, and pool hook validations.
     * @return hookFee0                Fees in token0 to take from the liquidity provider.
     * @return hookFee1                Fees in token1 to take from the liquidity provider.
     */
    function _executeLiquidityCollectFeesHooks(
        LiquidityCollectFeesParams calldata liquidityParams,
        LiquidityContext memory context,
        uint256 fees0,
        uint256 fees1,
        address poolHook,
        LiquidityHooksExtraData calldata liquidityHooksExtraData
    ) internal returns (uint256 hookFee0, uint256 hookFee1) {
        TokenSettings memory token0Settings = Storage.appStorage().tokenSettings[context.token0];
        TokenSettings memory token1Settings = Storage.appStorage().tokenSettings[context.token1];

        {
            (hookFee0, hookFee1) = _executeTokenLiquidityCollectFeesHook(
                true,
                context,
                liquidityParams,
                fees0,
                fees1,
                token0Settings,
                liquidityHooksExtraData.token0Hook
            );
        }
        {
            (uint256 _hookFee0, uint256 _hookFee1) = _executeTokenLiquidityCollectFeesHook(
                false,
                context,
                liquidityParams,
                fees0,
                fees1,
                token1Settings,
                liquidityHooksExtraData.token1Hook
            );

            hookFee0 += _hookFee0;
            hookFee1 += _hookFee1;
        }
        {
            (uint256 _hookFee0, uint256 _hookFee1) = _executePositionLiquidityCollectFeesHook(
                context,
                liquidityParams,
                fees0,
                fees1,
                liquidityHooksExtraData.liquidityHook
            );

            hookFee0 += _hookFee0;
            hookFee1 += _hookFee1;
        }
        {
            (uint256 _hookFee0, uint256 _hookFee1) = _executePoolLiquidityCollectFeesHook(
                poolHook,
                context,
                liquidityParams,
                fees0,
                fees1,
                liquidityHooksExtraData.poolHook
            );

            hookFee0 += _hookFee0;
            hookFee1 += _hookFee1;
        }
    }

    /**
     * @dev Executes token-specific fee collection validation hook if enabled.
     *
     * @dev Throws when token hook validation fails.
     *      Throws when hook contract call reverts.
     *
     *      Checks if the token has liquidity modification hooks enabled in its settings and executes
     *      the fee collection validation if required. The hook can reject the fee collection operation
     *      by reverting or throwing validation errors.
     *
     *      <h4>Postconditions:</h4>
     *      1. Token hook executed if enabled in token settings
     *      2. Fee collection operation validated by token hook
     *
     * @param hookForToken0    True if validating for token0, false for token1
     * @param context          Fee collection context with position owner and token information
     * @param liquidityParams  Parameters for fee collection including pool ID and pool-specific data
     * @param fees0            Amount of token0 fees being collected
     * @param fees1            Amount of token1 fees being collected
     * @param tokenSettings    Token configuration settings including hook flags
     * @param tokenHookData    Additional data to pass to the token's hook
     */
    function _executeTokenLiquidityCollectFeesHook(
        bool hookForToken0,
        LiquidityContext memory context,
        LiquidityCollectFeesParams calldata liquidityParams,
        uint256 fees0,
        uint256 fees1,
        TokenSettings memory tokenSettings,
        bytes calldata tokenHookData
    ) internal returns (uint256 hookFee0, uint256 hookFee1) {
        if (_isFlagSet(tokenSettings.packedSettings, TOKEN_SETTINGS_COLLECT_FEES_HOOK_FLAG)) {
            (hookFee0, hookFee1) = ILimitBreakAMMTokenHook(tokenSettings.tokenHook).validateCollectFees(
                hookForToken0, context, liquidityParams, fees0, fees1, tokenHookData
            );

            address feeFor = hookForToken0 ? context.token0 : context.token1;
            if (hookFee0 > 0) {
                _storeHookFees(feeFor, context.token0, tokenSettings, hookFee0);
            }

            if (hookFee1 > 0) {
                _storeHookFees(feeFor, context.token1, tokenSettings, hookFee1);
            }
        }
    }

    /**
     * @dev Executes position-specific fee collection validation hook if enabled.
     *
     * @dev Throws when position hook validation fails.
     *      Throws when hook contract call reverts.
     *
     *      Checks if a position hook address is specified in the liquidity parameters and executes
     *      the fee collection validation if required. The position hook can reject the fee collection
     *      operation by reverting or throwing validation errors.
     *
     *      <h4>Postconditions:</h4>
     *      1. Position hook executed if address is non-zero
     *      2. Fee collection operation validated by position hook
     *
     * @param context            Fee collection context with position owner and token information
     * @param liquidityParams    Parameters for fee collection including pool ID and hook address
     * @param fees0              Amount of token0 fees being collected
     * @param fees1              Amount of token1 fees being collected
     * @param liquidityHookData  Additional data to pass to the position hook
     */
    function _executePositionLiquidityCollectFeesHook(
        LiquidityContext memory context,
        LiquidityCollectFeesParams calldata liquidityParams,
        uint256 fees0,
        uint256 fees1,
        bytes calldata liquidityHookData
    ) internal returns (uint256 hookFee0, uint256 hookFee1) {
        address liquidityHook = liquidityParams.liquidityHook;
        if (liquidityHook != address(0)) {
            (hookFee0, hookFee1) = ILimitBreakAMMLiquidityHook(liquidityHook).validatePositionCollectFees(
                context,
                liquidityParams,
                fees0,
                fees1,
                liquidityHookData
            );

            if (hookFee0 > 0) {
                _storeNonTokenHookFees(liquidityHook, context.token0, hookFee0);
            }

            if (hookFee1 > 0) {
                _storeNonTokenHookFees(liquidityHook, context.token1, hookFee1);
            }
        }
    }

    /**
     * @dev Executes pool-specific fee collection validation hook if enabled.
     *
     * @dev Throws when pool hook validation fails.
     *      Throws when hook contract call reverts.
     *
     *      Checks if a pool hook address is provided and executes the fee collection validation
     *      if required. The pool hook can reject the fee collection operation by reverting or
     *      throwing validation errors.
     *
     *      <h4>Postconditions:</h4>
     *      1. Pool hook executed if address is non-zero
     *      2. Fee collection operation validated by pool hook
     *
     * @param poolHook        Address of the pool hook contract
     * @param context         Fee collection context with position owner and token information
     * @param liquidityParams Parameters for fee collection including pool ID and pool-specific data
     * @param fees0           Amount of token0 fees being collected
     * @param fees1           Amount of token1 fees being collected
     * @param poolHookData    Additional data to pass to the pool hook
     */
    function _executePoolLiquidityCollectFeesHook(
        address poolHook,
        LiquidityContext memory context,
        LiquidityCollectFeesParams calldata liquidityParams,
        uint256 fees0,
        uint256 fees1,
        bytes calldata poolHookData
    ) internal returns (uint256 hookFee0, uint256 hookFee1) {
        if (poolHook != address(0)) {
            (hookFee0, hookFee1) = ILimitBreakAMMPoolHook(poolHook).validatePoolCollectFees(
                context,
                liquidityParams,
                fees0,
                fees1,
                poolHookData
            );

            if (hookFee0 > 0) {
                _storeNonTokenHookFees(poolHook, context.token0, hookFee0);
            }

            if (hookFee1 > 0) {
                _storeNonTokenHookFees(poolHook, context.token1, hookFee1);
            }
        }
    }

    /**
     * @dev Executes all applicable hooks for liquidity addition operations.
     *
     * @dev Throws when any token hook validation fails.
     *      Throws when position hook validation fails.
     *      Throws when pool hook validation fails.
     *
     *      Wrapper function that delegates to the shared liquidity modification hook execution logic
     *      with the add liquidity flag set to true. This ensures consistent hook execution patterns
     *      across all liquidity operations while maintaining operation-specific behavior.
     *
     *      <h4>Developer Notes:</h4>
     *      - Uses validateAddLiquidity selectors for all hook calls
     *
     *      <h4>Postconditions:</h4>
     *      1. All applicable hooks executed successfully based on configuration
     *      2. Liquidity addition operation validated by all enabled hooks
     *      3. Hook execution completed in proper sequence
     *
     * @param liquidityParams         Parameters for liquidity addition including pool ID and minimum amounts
     * @param liquidityHooksExtraData Hook data for token, position, and pool hook validations
     * @param context                 Liquidity operation context with caller, provider, and token information
     * @param liquidityCache          Internal cache of liquidity modification values
     * @param poolHook                Address of the pool hook contract
     */
    function _executeAddLiquidityHooks(
        LiquidityModificationParams calldata liquidityParams,
        LiquidityHooksExtraData calldata liquidityHooksExtraData,
        LiquidityContext memory context,
        InternalLiquidityModificationCache memory liquidityCache,
        address poolHook
    ) internal returns (uint256 hookFee0, uint256 hookFee1) {
        (hookFee0, hookFee1) = _executeModifyLiquidityHooks(
            true,
            liquidityParams,
            liquidityHooksExtraData,
            context,
            liquidityCache,
            poolHook
        );
    }

    /**
     * @dev Executes all applicable hooks for liquidity removal operations.
     *
     * @dev Throws when any token hook validation fails.
     *      Throws when position hook validation fails.
     *      Throws when pool hook validation fails.
     *
     *      Wrapper function that delegates to the shared liquidity modification hook execution logic
     *      with the add liquidity flag set to false. This ensures consistent hook execution patterns
     *      across all liquidity operations while maintaining operation-specific behavior.
     *
     *      <h4>Developer Notes:</h4>
     *      - Uses validateRemoveLiquidity selectors for all hook calls
     *
     *      <h4>Postconditions:</h4>
     *      1. All applicable hooks executed successfully based on configuration
     *      2. Liquidity removal operation validated by all enabled hooks
     *      3. Hook execution completed in proper sequence
     *
     * @param liquidityParams         Parameters for liquidity removal including pool ID and minimum amounts
     * @param liquidityHooksExtraData Hook data for token, position, and pool hook validations
     * @param context                 Liquidity operation context with caller, provider, and token information
     * @param liquidityCache          Internal cache of liquidity modification values
     * @param poolHook                Address of the pool hook contract
     */
    function _executeRemoveLiquidityHooks(
        LiquidityModificationParams calldata liquidityParams,
        LiquidityHooksExtraData calldata liquidityHooksExtraData,
        LiquidityContext memory context,
        InternalLiquidityModificationCache memory liquidityCache,
        address poolHook
    ) internal returns (uint256 hookFee0, uint256 hookFee1) {
        (hookFee0, hookFee1) = _executeModifyLiquidityHooks(
            false,
            liquidityParams,
            liquidityHooksExtraData,
            context,
            liquidityCache,
            poolHook
        );
    }

    /**
     * @dev Executes all applicable hooks for liquidity modification operations in strict sequence.
     *
     * @dev Throws when any token hook validation fails.
     *      Throws when position hook validation fails.
     *      Throws when pool hook validation fails.
     *
     *      Shared implementation for both add and remove liquidity operations. Executes hooks in
     *      strict order: token0, token1, position, pool. Each hook receives the operation type
     *      flag and can validate or reject the liquidity modification.
     *
     *      <h4>Postconditions:</h4>
     *      1. Token hooks executed if enabled in token settings
     *      2. Position hook executed if address is non-zero
     *      3. Pool hook executed if address is non-zero
     *
     * @param addLiquidityHooks       True for add liquidity operations, false for remove operations
     * @param liquidityParams         Pool ID, amounts, and hook address for validation context
     * @param liquidityHooksExtraData Hook data for token, position, and pool hook validations
     * @param context                 Liquidity operation context with caller, provider, and token information
     * @param liquidityCache          Internal cache of liquidity modification values
     * @param poolHook                Address of the pool hook contract
     */
    function _executeModifyLiquidityHooks(
        bool addLiquidityHooks,
        LiquidityModificationParams calldata liquidityParams,
        LiquidityHooksExtraData calldata liquidityHooksExtraData,
        LiquidityContext memory context,
        InternalLiquidityModificationCache memory liquidityCache,
        address poolHook
    ) internal returns (uint256 hookFee0, uint256 hookFee1) {
        {
            TokenSettings memory token0Settings = Storage.appStorage().tokenSettings[context.token0];
            (hookFee0, hookFee1) = _executeTokenModifyLiquidityHook(
                addLiquidityHooks,
                true,
                context,
                liquidityParams,
                liquidityHooksExtraData.token0Hook,
                liquidityCache,
                token0Settings
            );
        }
        {
            TokenSettings memory token1Settings = Storage.appStorage().tokenSettings[context.token1];
            (uint256 _hookFee0, uint256 _hookFee1) = _executeTokenModifyLiquidityHook(
                addLiquidityHooks,
                false,
                context,
                liquidityParams,
                liquidityHooksExtraData.token1Hook,
                liquidityCache,
                token1Settings
            );

            hookFee0 += _hookFee0;
            hookFee1 += _hookFee1;
        }
        {
            (uint256 _hookFee0, uint256 _hookFee1) = _executePositionModifyLiquidityHook(
                addLiquidityHooks,
                context,
                liquidityParams,
                liquidityHooksExtraData.liquidityHook,
                liquidityCache
            );

            hookFee0 += _hookFee0;
            hookFee1 += _hookFee1;
        }
        {
            (uint256 _hookFee0, uint256 _hookFee1) = _executePoolModifyLiquidityHook(
                addLiquidityHooks,
                poolHook,
                context,
                liquidityParams,
                liquidityHooksExtraData.poolHook,
                liquidityCache
            );

            hookFee0 += _hookFee0;
            hookFee1 += _hookFee1;
        }
    }

    /**
     * @dev Executes token-specific liquidity modification validation hook if enabled.
     *
     * @dev Throws when token hook validation fails.
     *      Throws when hook contract call reverts.
     *
     *      Checks if the token has liquidity modification hooks enabled and executes the appropriate
     *      validation function based on the operation type. Uses dynamic selector resolution to call
     *      either validateAddLiquidity or validateRemoveLiquidity on the token hook contract.
     *
     *      <h4>Postconditions:</h4>
     *      1. Token hook executed if enabled in token settings
     *      2. Appropriate validation function called based on operation type
     *
     * @param addLiquidityHooks  True for add liquidity operations, false for remove operations
     * @param hookForToken0      True if validating for token0, false for token1
     * @param context            Liquidity operation context with caller, provider, and token information
     * @param liquidityParams    Parameters for liquidity modification including pool ID and amounts
     * @param tokenHookData      Additional data to pass to the token's hook
     * @param liquidityCache     Internal cache of liquidity modification values
     * @param tokenSettings      Token configuration settings including hook flags and addresses
     */
    function _executeTokenModifyLiquidityHook(
        bool addLiquidityHooks,
        bool hookForToken0,
        LiquidityContext memory context,
        LiquidityModificationParams calldata liquidityParams,
        bytes calldata tokenHookData,
        InternalLiquidityModificationCache memory liquidityCache,
        TokenSettings memory tokenSettings
    ) internal returns (uint256 hookFee0, uint256 hookFee1) {
        if (addLiquidityHooks) {
            if (_isFlagSet(tokenSettings.packedSettings, TOKEN_SETTINGS_ADD_LIQUIDITY_HOOK_FLAG)) {
                bytes memory data = abi.encodeWithSelector(
                    ILimitBreakAMMTokenHook.validateAddLiquidity.selector,
                    hookForToken0,
                    context,
                    liquidityParams,
                    liquidityCache.amount0,
                    liquidityCache.amount1,
                    liquidityCache.fees0,
                    liquidityCache.fees1,
                    tokenHookData
                );
                (bool success, bytes memory returnData) = tokenSettings.tokenHook.call(data);
                if (!success) {
                    assembly ("memory-safe") {
                        revert(add(returnData, 0x20), mload(returnData))
                    }
                }

                (hookFee0, hookFee1) = abi.decode(returnData, (uint256,uint256));
                address feeFor = hookForToken0 ? context.token0 : context.token1;
                if (hookFee0 > 0) {
                    _storeHookFees(feeFor, context.token0, tokenSettings, hookFee0);
                }

                if (hookFee1 > 0) {
                    _storeHookFees(feeFor, context.token1, tokenSettings, hookFee1);
                }
            }
        } else {
            if (_isFlagSet(tokenSettings.packedSettings, TOKEN_SETTINGS_REMOVE_LIQUIDITY_HOOK_FLAG)) {
                bytes memory data = abi.encodeWithSelector(
                    ILimitBreakAMMTokenHook.validateRemoveLiquidity.selector,
                    hookForToken0,
                    context,
                    liquidityParams,
                    liquidityCache.amount0,
                    liquidityCache.amount1,
                    liquidityCache.fees0,
                    liquidityCache.fees1,
                    tokenHookData
                );
                (bool success, bytes memory returnData) = tokenSettings.tokenHook.call(data);
                if (!success) {
                    assembly ("memory-safe") {
                        revert(add(returnData, 0x20), mload(returnData))
                    }
                }

                (hookFee0, hookFee1) = abi.decode(returnData, (uint256,uint256));
                address feeFor = hookForToken0 ? context.token0 : context.token1;
                if (hookFee0 > 0) {
                    _storeHookFees(feeFor, context.token0, tokenSettings, hookFee0);
                }

                if (hookFee1 > 0) {
                    _storeHookFees(feeFor, context.token1, tokenSettings, hookFee1);
                }
            }
        }
    }

    /**
     * @dev Executes position-specific liquidity modification validation hook if enabled.
     *
     * @dev Throws when position hook validation fails.
     *      Throws when hook contract call reverts.
     *
     *      Checks if a position hook address is specified in the liquidity parameters and executes
     *      the appropriate validation function based on the operation type. Uses dynamic selector
     *      resolution to call either validateAddLiquidity or validateRemoveLiquidity.
     *
     *      <h4>Postconditions:</h4>
     *      1. Position hook executed if address is non-zero
     *      2. Appropriate validation function called based on operation type
     *
     * @param addLiquidityHooks True for add liquidity operations, false for remove operations
     * @param context           Liquidity operation context with caller, provider, and token information
     * @param liquidityParams   Parameters for liquidity modification including pool ID and hook address
     * @param liquidityHookData Additional data to pass to the position hook
     * @param liquidityCache    Internal cache of liquidity modification values
     */
    function _executePositionModifyLiquidityHook(
        bool addLiquidityHooks,
        LiquidityContext memory context,
        LiquidityModificationParams calldata liquidityParams,
        bytes calldata liquidityHookData,
        InternalLiquidityModificationCache memory liquidityCache
    ) internal returns (uint256 hookFee0, uint256 hookFee1) {
        address liquidityHook = liquidityParams.liquidityHook;
        if (liquidityHook != address(0)) {
            bytes memory data = abi.encodeWithSelector(
                addLiquidityHooks ? 
                    ILimitBreakAMMLiquidityHook.validatePositionAddLiquidity.selector : 
                    ILimitBreakAMMLiquidityHook.validatePositionRemoveLiquidity.selector,
                context,
                liquidityParams,
                liquidityCache.amount0,
                liquidityCache.amount1,
                liquidityCache.fees0,
                liquidityCache.fees1,
                liquidityHookData
            );
            (bool success, bytes memory returnData) = liquidityHook.call(data);
            if (!success) {
                assembly ("memory-safe") {
                    revert(add(returnData, 0x20), mload(returnData))
                }
            }

            (hookFee0, hookFee1) = abi.decode(returnData, (uint256,uint256));
            if (hookFee0 > 0) {
                _storeNonTokenHookFees(liquidityHook, context.token0, hookFee0);
            }

            if (hookFee1 > 0) {
                _storeNonTokenHookFees(liquidityHook, context.token1, hookFee1);
            }
        }
    }

    /**
     * @dev Executes pool-specific liquidity modification validation hook if enabled.
     *
     * @dev Throws when pool hook validation fails.
     *      Throws when hook contract call reverts.
     *
     *      Checks if a pool hook address is provided and executes the appropriate validation function 
     *      based on the operation type. Uses dynamic selector resolution to call either 
     *      validateAddLiquidity or validateRemoveLiquidity on the pool hook contract.
     *
     *      <h4>Postconditions:</h4>
     *      1. Pool hook executed if address is non-zero
     *      2. Appropriate validation function called based on operation type
     *
     * @param addLiquidityHooks True for add liquidity operations, false for remove operations
     * @param poolHook          Address of the pool hook contract
     * @param context           Liquidity operation context with caller, provider, and token information
     * @param liquidityParams   Parameters for liquidity modification including pool ID and amounts
     * @param poolHookData      Additional data to pass to the pool hook
     * @param liquidityCache    Internal cache of liquidity modification values
     */
    function _executePoolModifyLiquidityHook(
        bool addLiquidityHooks,
        address poolHook,
        LiquidityContext memory context,
        LiquidityModificationParams calldata liquidityParams,
        bytes calldata poolHookData,
        InternalLiquidityModificationCache memory liquidityCache
    ) internal returns (uint256 hookFee0, uint256 hookFee1) {
        if (poolHook != address(0)) {
            bytes memory data = abi.encodeWithSelector(
                addLiquidityHooks ? 
                    ILimitBreakAMMPoolHook.validatePoolAddLiquidity.selector : 
                    ILimitBreakAMMPoolHook.validatePoolRemoveLiquidity.selector,
                context,
                liquidityParams,
                liquidityCache.amount0,
                liquidityCache.amount1,
                liquidityCache.fees0,
                liquidityCache.fees1,
                poolHookData
            );
            (bool success, bytes memory returnData) = poolHook.call(data);
            if (!success) {
                assembly ("memory-safe") {
                    revert(add(returnData, 0x20), mload(returnData))
                }
            }

            (hookFee0, hookFee1) = abi.decode(returnData, (uint256,uint256));
            if (hookFee0 > 0) {
                _storeNonTokenHookFees(poolHook, context.token0, hookFee0);
            }

            if (hookFee1 > 0) {
                _storeNonTokenHookFees(poolHook, context.token1, hookFee1);
            }
        }
    }

    /**
     * @dev Handles token distribution and collection for liquidity operations with native value support.
     *
     * @dev Throws when native value sent but not used for wrapped native operations.
     *
     *      Processes both tokens by calling distribution/collection logic for each. Validates that any
     *      sent native value is properly utilized for wrapped native token operations.
     *
     *      <h4>Postconditions:</h4>
     *      1. Both tokens processed for distribution or collection
     *      2. Native value validated as used if sent
     *
     * @param  provider    Address providing or receiving liquidity.
     * @param  token0      First token address.
     * @param  token1      Second token address.
     * @param  netAmount0  Net amount for token0 (positive = collect, negative = distribute).
     * @param  netAmount1  Net amount for token1 (positive = collect, negative = distribute).
     */
    function _distributeAndCollectLiquidityTokens(
        address provider,
        address token0,
        address token1,
        int256 netAmount0,
        int256 netAmount1
    ) internal {
        bool nativeValueUsed0 = _distributeOrCollectLiquidityToken(provider, token0, netAmount0);
        bool nativeValueUsed1 = _distributeOrCollectLiquidityToken(provider, token1, netAmount1);

        if (msg.value > 0 && !(nativeValueUsed0 || nativeValueUsed1)) {
            revert LBAMM__ValueNotUsed();
        }
    }

    /**
     * @dev Distributes or collects a single token for liquidity operations.
     *
     * @dev Throws when token transfer fails.
     *
     *      For positive amounts: collects tokens from provider using native value if applicable for
     *      wrapped native token. For negative amounts: distributes tokens to provider using native
     *      withdrawals for wrapped native or storing as owed amounts if transfer fails.
     *
     *      <h4>Postconditions:</h4>
     *      1. Tokens collected from provider if net amount positive
     *      2. Tokens distributed to provider if net amount negative
     *      3. Native value used for wrapped native operations if applicable
     *      4. Failed transfers stored as owed amounts
     *
     * @param  provider        Address providing or receiving tokens.
     * @param  token           Token address being processed.
     * @param  netAmount       Net token amount (positive = collect, negative = distribute).
     * @return nativeValueUsed True if native value was used for wrapped native operations.
     */
    function _distributeOrCollectLiquidityToken(address provider, address token, int256 netAmount)
        internal
        returns (bool nativeValueUsed)
    {
        if (netAmount > 0) {
            if (msg.value > 0 && token == address(wrappedNative)) {
                _depositWrappedNativeAndRefundExcess(provider, uint256(netAmount));
                nativeValueUsed = true;
            } else {
                _collectToken(provider, token, uint256(netAmount));
            }
        } else if (netAmount < 0) {
            uint256 unsignedAmount = uint256(-netAmount);
            if (token == address(wrappedNative)) {
                wrappedNative.withdrawToAccount(provider, unsignedAmount);
            } else {
                bool isError = SafeERC20.safeTransfer(token, provider, unsignedAmount);
                if (isError) {
                    _storeTokensOwed(provider, token, unsignedAmount);
                }
            }
        }
    }

    ///////////////////////////////////////////////////////
    //                     POOL SWAPS                    //
    ///////////////////////////////////////////////////////

    /**
     * @dev Executes an input-based swap through an AMM pool with comprehensive fee handling.
     *
     * @dev Throws when the pool does not exist or tokenIn is invalid for the pool.
     *      Throws when pool type contract call reverts.
     *      Throws when token hook validations fail.
     *      Throws when reserve or fee balance updates cause overflow.
     *      Throws when protocol fee validation fails.
     *      Throws when a swap partial fills on a multihop swap after the first swap.
     *      Throws when a swap partial fills in an amount less than the minimum amount specified. 
     *
     *      Determines swap direction based on input token, executes before-swap hooks, delegates
     *      swap calculation to pool type contract, updates pool state, executes after-swap hooks,
     *      and handles protocol fee storage. Fee processing includes input fees, pool fees,
     *      output fees, and protocol revenue sharing.
     *
     *      <h4>Developer Notes:</h4>
     *      - Token direction determined by comparing tokenIn with pool's token0/token1
     *      - Pool fees can be static or dynamic based on pool configuration
     *      - Protocol fees stored immediately for single swaps, deferred for multi-hop
     *      - Final amountIn becomes amountOut for next hop in multi-hop swaps
     *
     *      <h4>Postconditions:</h4>
     *      1. Pool reserves updated based on swap direction
     *      2. Pool fee balances increased by collected fees
     *      3. Before and after swap hooks executed successfully
     *      4. Protocol fees stored immediately if single swap, deferred if multi-hop
     *      5. Swap cache updated with output amounts for next hop
     *
     * @param swapCache           Swap operation context and state tracking
     * @param singleSwap          True if this is a single swap, false for multi-hop
     * @param swapHooksExtraData  Hook data for token and pool hook validations
     */
    function _poolSwapByInput(
        InternalSwapCache memory swapCache,
        bool singleSwap,
        SwapHooksExtraData calldata swapHooksExtraData
    ) internal {
        PoolState storage ptrPoolState = Storage.appStorage().pools[swapCache.poolId];
        _loadLPProtocolFee(swapCache);
        TokenSettings memory tokenInSettings;
        TokenSettings memory tokenOutSettings;

        swapCache.protocolFee = 0;

        // Swap calculation
        tokenInSettings = Storage.appStorage().tokenSettings[swapCache.nextToken];
        swapCache.tokenIn = swapCache.nextToken;

        if (ptrPoolState.token0 == swapCache.tokenIn) {
            swapCache.tokenOut = ptrPoolState.token1;
            swapCache.zeroForOne = true;
        } else if (ptrPoolState.token1 == swapCache.tokenIn) {
            swapCache.tokenOut = ptrPoolState.token0;
            swapCache.zeroForOne = false;
        } else {
            revert LBAMM__InvalidPoolId();
        }

        tokenOutSettings = Storage.appStorage().tokenSettings[swapCache.tokenOut];
        swapCache.nextToken = swapCache.tokenOut;

        _executeBeforeSwapHooks(swapCache, tokenInSettings, tokenOutSettings, swapHooksExtraData);
        uint16 poolFeeBPS = _getPoolFee(swapCache, swapCache.amountIn, swapHooksExtraData);
        _applySwapByInputInputFees(swapCache, tokenInSettings, tokenOutSettings, poolFeeBPS);

        uint16 lpFeeBPS = swapCache.protocolFeeStructure.lpFeeBPS;
        uint256 poolFeeOfAmountIn;
        uint256 poolProtocolFees;
        {
            //stack management
            InternalSwapCache memory tmpSwapCache = swapCache;
            SwapHooksExtraData calldata tmpSwapHooksExtraData = swapHooksExtraData;
            uint256 actualAmountIn;
            (
                actualAmountIn,
                tmpSwapCache.amountOut,
                poolFeeOfAmountIn,
                poolProtocolFees
            ) = ILimitBreakAMMPoolType(PoolDecoder.getPoolType(tmpSwapCache.poolId)).swapByInput(
                tmpSwapCache.context,
                tmpSwapCache.poolId,
                tmpSwapCache.zeroForOne,
                tmpSwapCache.amountIn,
                poolFeeBPS,
                lpFeeBPS,
                tmpSwapHooksExtraData.poolType
            );

            uint256 originalAmountIn = tmpSwapCache.amountIn;
            if (actualAmountIn != originalAmountIn) {
                if (actualAmountIn < tmpSwapCache.minAmountSpecified) {
                    revert LBAMM__PartialFillLessThanMinimumSpecified();
                }

                if (actualAmountIn > originalAmountIn) {
                    revert LBAMM__ActualAmountCannotExceedInitialAmount();
                }

                if (tmpSwapCache.hopIndex != 0) {
                    revert LBAMM__CannotPartialFillAfterFirstHop();
                }

                unchecked {
                    // Adjust fees to compensate for partial fill
                    tmpSwapCache.expectedLPFee = FullMath.mulDivRoundingUp(tmpSwapCache.expectedLPFee, actualAmountIn, originalAmountIn);
                    tmpSwapCache.expectedProtocolLPFee = FullMath.mulDivRoundingUp(tmpSwapCache.expectedProtocolLPFee, actualAmountIn, originalAmountIn);
                    tmpSwapCache.amountIn = actualAmountIn;

                    uint256 amountInAdjustment = originalAmountIn - actualAmountIn;
                    uint256 exchangeFeeAdjustment = FullMath.mulDiv(tmpSwapCache.exchangeFeeAmount, amountInAdjustment, originalAmountIn);
                    uint256 protocolExchangeFeeAdjustment = FullMath.mulDiv(tmpSwapCache.protocolExchangeFeeAmount, amountInAdjustment, originalAmountIn);

                    tmpSwapCache.adjustedAmountSpecified = tmpSwapCache.adjustedAmountSpecified - amountInAdjustment
                        - exchangeFeeAdjustment - protocolExchangeFeeAdjustment;
                    tmpSwapCache.exchangeFeeAmount -= exchangeFeeAdjustment;
                    tmpSwapCache.protocolFeeFromFees -= protocolExchangeFeeAdjustment;
                }
            }
        }

        uint256 reserveIn = _validateProtocolFees(swapCache, poolFeeOfAmountIn, poolProtocolFees, true);

        swapCache.protocolFee += poolProtocolFees;

        if (swapCache.zeroForOne) {
            ptrPoolState.reserve0 = _safeIncrementUint128(ptrPoolState.reserve0, reserveIn);
            ptrPoolState.reserve1 = _safeDecrementUint128(ptrPoolState.reserve1, swapCache.amountOut);
            ptrPoolState.feeBalance0 = _safeIncrementUint128(ptrPoolState.feeBalance0, poolFeeOfAmountIn);
        } else {
            ptrPoolState.reserve0 = _safeDecrementUint128(ptrPoolState.reserve0, swapCache.amountOut);
            ptrPoolState.reserve1 = _safeIncrementUint128(ptrPoolState.reserve1, reserveIn);
            ptrPoolState.feeBalance1 = _safeIncrementUint128(ptrPoolState.feeBalance1, poolFeeOfAmountIn);
        }

        _executeAfterSwapHooks(swapCache, tokenInSettings, tokenOutSettings, swapHooksExtraData);
        _applySwapByInputOutputFees(swapCache, tokenInSettings, tokenOutSettings);

        {
            // Protocol fee calculation
            uint256 protocolFee = swapCache.protocolFee;
            if (protocolFee > 0) {
                if (singleSwap) {
                    swapCache.protocolFeeFromFees += protocolFee;
                } else {
                    _storeProtocolFees(swapCache.tokenIn, protocolFee);
                }
            }
        }

        emit Swap(
            swapCache.poolId,
            swapCache.context.recipient,
            swapCache.zeroForOne,
            swapCache.amountIn,
            swapCache.amountOut,
            poolFeeOfAmountIn
        );

        swapCache.amountIn = swapCache.amountOut;
    }

    /**
     * @dev Executes an output-based swap through an AMM pool with comprehensive fee handling.
     *
     * @dev Throws when the pool does not exist or tokenOut is invalid for the pool.
     *      Throws when pool type contract call reverts.
     *      Throws when token hook validations fail.
     *      Throws when reserve or fee balance updates cause overflow.
     *      Throws when protocol fee validation fails.
     *      Throws when a swap partial fills on a multihop swap after the first swap.
     *      Throws when a swap partial fills in an amount less than the minimum amount specified.
     *
     *      Determines swap direction based on output token, executes before-swap hooks, applies output fees,
     *      delegates swap calculation to pool type contract, updates pool state, executes after-swap hooks,
     *      applies input fees, and handles protocol fee storage. Fee processing includes output fees first,
     *      then pool fees, input fees, and protocol revenue sharing.
     *
     *      <h4>Developer Notes:</h4>
     *      - Token direction determined by comparing tokenOut with pool's token0/token1
     *      - Pool fees can be static or dynamic based on pool configuration
     *      - Protocol fees stored immediately for single swaps, deferred for multi-hop
     *      - Final amountOut becomes amountIn for next hop in multi-hop swaps
     *      - Fee application order differs from input-based: output fees before pool calculation
     *
     *      <h4>Postconditions:</h4>
     *      1. Pool reserves updated based on swap direction
     *      2. Pool fee balances increased by collected fees
     *      3. Before and after swap hooks executed successfully
     *      4. Protocol fees stored immediately if single swap, deferred if multi-hop
     *      5. Swap cache updated with input amounts for next hop
     *
     * @param swapCache           Swap operation context and state tracking
     * @param singleSwap          True if this is a single swap, false for multi-hop
     * @param swapHooksExtraData  Hook data for token and pool hook validations
     */
    function _poolSwapByOutput(
        InternalSwapCache memory swapCache,
        bool singleSwap,
        SwapHooksExtraData calldata swapHooksExtraData
    ) internal {
        PoolState storage ptrPoolState = Storage.appStorage().pools[swapCache.poolId];
        _loadLPProtocolFee(swapCache);
        TokenSettings memory tokenInSettings;
        TokenSettings memory tokenOutSettings;

        swapCache.protocolFee = 0;

        // Swap calculation
        tokenOutSettings = Storage.appStorage().tokenSettings[swapCache.nextToken];
        swapCache.tokenOut = swapCache.nextToken;

        if (ptrPoolState.token0 == swapCache.tokenOut) {
            swapCache.tokenIn = ptrPoolState.token1;
            swapCache.zeroForOne = false;
        } else if (ptrPoolState.token1 == swapCache.tokenOut) {
            swapCache.tokenIn = ptrPoolState.token0;
            swapCache.zeroForOne = true;
        } else {
            revert LBAMM__InvalidPoolId();
        }

        tokenInSettings = Storage.appStorage().tokenSettings[swapCache.tokenIn];
        swapCache.nextToken = swapCache.tokenIn;


        _executeBeforeSwapHooks(swapCache, tokenInSettings, tokenOutSettings, swapHooksExtraData);
        _applySwapByOutputOutputFees(swapCache, tokenInSettings, tokenOutSettings);
        uint16 poolFeeBPS = _getPoolFee(swapCache, swapCache.amountOut, swapHooksExtraData);

        uint256 actualAmountOut;
        uint256 poolFeeOfAmountIn;

        (
            actualAmountOut,
            swapCache.amountIn,
            poolFeeOfAmountIn,
            swapCache.protocolFee
        ) = ILimitBreakAMMPoolType(PoolDecoder.getPoolType(swapCache.poolId)).swapByOutput(
            swapCache.context,
            swapCache.poolId,
            swapCache.zeroForOne,
            swapCache.amountOut,
            poolFeeBPS,
            swapCache.protocolFeeStructure.lpFeeBPS,
            swapHooksExtraData.poolType
        );

        uint256 originalAmountOut = swapCache.amountOut;
        if (actualAmountOut != originalAmountOut) {
            unchecked {
                if (actualAmountOut > originalAmountOut) {
                    revert LBAMM__ActualAmountCannotExceedInitialAmount();
                }

                if (swapCache.hopIndex != 0) {
                    revert LBAMM__CannotPartialFillAfterFirstHop();
                }

                uint256 amountOutAdjustment = originalAmountOut - actualAmountOut;
                uint256 originalAdjustedAmountSpecified = swapCache.adjustedAmountSpecified;

                if (amountOutAdjustment > originalAdjustedAmountSpecified) {
                    revert LBAMM__PartialFillLessThanFees();
                }

                uint256 adjustedAmountSpecified = swapCache.adjustedAmountSpecified = originalAdjustedAmountSpecified - amountOutAdjustment;
                swapCache.amountOut = actualAmountOut;

                if (adjustedAmountSpecified < swapCache.minAmountSpecified) {
                    revert LBAMM__PartialFillLessThanMinimumSpecified();
                }
            }
        }

        uint256 reserveIn = _validateProtocolFees(swapCache, poolFeeOfAmountIn, swapCache.protocolFee, false);

        if (swapCache.zeroForOne) {
            ptrPoolState.reserve0 = _safeIncrementUint128(ptrPoolState.reserve0, reserveIn);
            ptrPoolState.reserve1 = _safeDecrementUint128(ptrPoolState.reserve1, swapCache.amountOut);
            ptrPoolState.feeBalance0 = _safeIncrementUint128(ptrPoolState.feeBalance0, poolFeeOfAmountIn);
        } else {
            ptrPoolState.reserve0 = _safeDecrementUint128(ptrPoolState.reserve0, swapCache.amountOut);
            ptrPoolState.reserve1 = _safeIncrementUint128(ptrPoolState.reserve1, reserveIn);
            ptrPoolState.feeBalance1 = _safeIncrementUint128(ptrPoolState.feeBalance1, poolFeeOfAmountIn);
        }

        _executeAfterSwapHooks(swapCache, tokenInSettings, tokenOutSettings, swapHooksExtraData);

        {
            uint256 lpProtocolFeeAmount = swapCache.protocolFee;
            _applySwapByOutputInputFees(swapCache, tokenInSettings, tokenOutSettings, lpProtocolFeeAmount);
            swapCache.protocolFee += lpProtocolFeeAmount;
        }

        {
            // Protocol fee calculation
            uint256 protocolFee = swapCache.protocolFee;
            if (protocolFee > 0) {
                if (singleSwap) {
                    swapCache.protocolFeeFromFees += protocolFee;
                } else {
                    _storeProtocolFees(swapCache.tokenIn, protocolFee);
                }
            }
        }

        emit Swap(
            swapCache.poolId,
            swapCache.context.recipient,
            swapCache.zeroForOne,
            swapCache.amountIn,
            swapCache.amountOut,
            poolFeeOfAmountIn
        );

        swapCache.amountOut = swapCache.amountIn;
    }

    /**
     * @dev Validates protocol fee amounts and calculates the actual reserve amount for pool updates.
     *
     * @dev Throws when total fees exceed the input amount.
     *      Throws when pool protocol fees are insufficient based on LP fee percentage.
     *
     *      Ensures that the combination of pool fees and protocol fees does not exceed the input amount
     *      and that the protocol receives the correct percentage of total fees as specified by the LP fee
     *      structure. Calculates the remaining amount that should be added to pool reserves.
     *
     *      <h4>Developer Notes:</h4>
     *      - Expected protocol fee calculated as percentage of total fees
     *      - Validation prevents fee calculation errors from corrupting pool state
     *
     *      <h4>Postconditions:</h4>
     *      1. Total fees validated as not exceeding input amount
     *      2. Protocol fee validated as meeting minimum requirements
     *      3. Reserve amount calculated for pool state updates
     *
     * @param swapCache         Swap operation context and state.
     * @param poolFeeOfAmountIn Amount of fees collected by the pool (LP fees)
     * @param poolProtocolFees  Amount of protocol fees collected by the pool
     * @param inputSwap         True if the swap is an input-based swap.
     * @return reserveIn        Amount to be added to pool reserves after fee deduction
     */
    function _validateProtocolFees(
        InternalSwapCache memory swapCache,
        uint256 poolFeeOfAmountIn,
        uint256 poolProtocolFees,
        bool inputSwap
    ) internal pure returns (uint256 reserveIn) {
        uint256 amountIn = swapCache.amountIn;
        uint256 totalFees = poolFeeOfAmountIn + poolProtocolFees;
        if (totalFees > amountIn) {
            revert LBAMM__FeeAmountExceedsInputAmount();
        }
        uint256 expectedProtocolFee = FullMath.mulDiv(totalFees, swapCache.protocolFeeStructure.lpFeeBPS, MAX_BPS);
        if (inputSwap) {
            if (totalFees < swapCache.expectedLPFee) {
                expectedProtocolFee = swapCache.expectedProtocolLPFee;
            }
        }
        if (poolProtocolFees < expectedProtocolFee) {
            revert LBAMM__InsufficientProtocolFee();
        }
        unchecked {
            reserveIn = amountIn - totalFees;
        }
    }

    /**
     * @dev Loads the pool's protocol LP fee if overridden, otherwise loads the default.
     * 
     * @param  swapCache  Memory structure to load pool fee into.
     */
    function _loadLPProtocolFee(InternalSwapCache memory swapCache) internal view {
        ProtocolFeeOverride storage ptrFeeOverride = Storage.appStorage().lpProtocolFeeOverride[swapCache.poolId];
        swapCache.protocolFeeStructure.lpFeeBPS = 
            ptrFeeOverride.feeOverrideEnabled ? ptrFeeOverride.protocolFeeBPS : swapCache.defaultProtocolLPFeeBPS;
    }

    /**
     * @dev Determines pool fee rate for swap operations.
     *
     * @dev Throws when pool hook returns invalid fee rate above maximum.
     *
     *      Returns static pool fee directly, or queries pool hook for dynamic fee when pool fee equals 
     *      DYNAMIC_POOL_FEE_BPS indicator value.
     *
     *      <h4>Postconditions:</h4>
     *      1. Pool hook queried if dynamic fees enabled
     *
     * @param  swapCache            Swap operation context and state.
     * @param  amount               Amount being swapped for fee calculation.
     * @param  swapHooksExtraData   Hook data for pool fee queries.
     * @return poolFeeBPS           Pool fee rate in basis points.
     */
    function _getPoolFee(
        InternalSwapCache memory swapCache,
        uint256 amount,
        SwapHooksExtraData calldata swapHooksExtraData
    ) internal returns (uint16 poolFeeBPS) {
        poolFeeBPS = PoolDecoder.getPoolFee(swapCache.poolId);
        if (poolFeeBPS == DYNAMIC_POOL_FEE_BPS) {
            poolFeeBPS = _executePoolFeeHook(
                swapCache, amount, swapHooksExtraData.poolHook, Storage.appStorage().pools[swapCache.poolId].poolHook
            );
            
            if ((swapCache.inputSwap && poolFeeBPS > MAX_BPS) || poolFeeBPS >= MAX_BPS) {
                revert LBAMM__InvalidPoolFeeBPS();
            }
        }
    }

    /**
     * @dev Queries pool hook for dynamic fee determination.
     *
     * @dev Throws when hook call fails or reverts.
     *
     *      Uses optimized assembly to call pool hook contract for dynamic fee calculation. Validates
     *      returned fee rate to ensure it does not exceed system maximum.
     *
     *      <h4>Postconditions:</h4>
     *      1. Hook memory allocated if not already available
     *      2. Pool hook called for fee determination
     *
     * @param  swapCache     Swap operation context and state.
     * @param  amount        Amount being swapped for fee calculation.
     * @param  hookData      Hook-specific calldata.
     * @param  hook          Address of the pool hook contract.
     * @return poolFeeBPS    Dynamic fee rate in basis points returned by the pool hook.
     */
    function _executePoolFeeHook(
        InternalSwapCache memory swapCache,
        uint256 amount,
        bytes calldata hookData,
        address hook
    ) internal returns (uint16 poolFeeBPS) {
        uint256 hookMemoryPointer = swapCache.hookMemoryPointer;
        if (hookMemoryPointer == 0) {
            hookMemoryPointer = swapCache.hookMemoryPointer = _allocateHookMemory(swapCache);
        }

        unchecked {
            if (swapCache.inputSwap) {
                uint256 totalHookFees = swapCache.tokenInTokenInFee + swapCache.tokenOutTokenInFee;
                // Underflow will be checked in _applySwapByInputInputFees
                amount -= totalHookFees;
            }
        }

        bytes4 functionSelector = ILimitBreakAMMPoolHook.getPoolFeeForSwap.selector;
        uint256 hopIndex = swapCache.hopIndex;
        bytes32 poolId = swapCache.poolId;
        address tokenIn = swapCache.tokenIn;
        address tokenOut = swapCache.tokenOut;
        assembly ("memory-safe") {
            mstore(hookMemoryPointer, shr(0xE0, functionSelector))
            mstore(add(hookMemoryPointer, 0x180), hopIndex)
            mstore(add(hookMemoryPointer, 0x1A0), poolId)
            mstore(add(hookMemoryPointer, 0x1C0), tokenIn)
            mstore(add(hookMemoryPointer, 0x1E0), tokenOut)
            mstore(add(hookMemoryPointer, 0x200), amount)
            mstore(add(hookMemoryPointer, 0x220), 0x220)
            let hookDataLength := hookData.length
            let hookDataCopyLength := and(not(0x1F), add(hookDataLength, 0x1F))
            mstore(add(hookMemoryPointer, 0x240), hookDataLength)
            calldatacopy(add(hookMemoryPointer, 0x260), hookData.offset, hookDataCopyLength)

            let success :=
                call(gas(), hook, 0x00, add(hookMemoryPointer, 0x1C), add(0x244, hookDataCopyLength), 0x00, 0x20)
            if iszero(success) {
                returndatacopy(0x00, 0x00, returndatasize())
                revert(0x00, returndatasize())
            }
            if lt(returndatasize(), 0x20) {
                mstore(0x00, 0xacf83667) // LBAMM__InvalidPoolFeeHook
                revert(0x1C, 0x04)
            }
            poolFeeBPS := mload(0x00)
        }
    }

    ///////////////////////////////////////////////////////
    //                   DIRECT SWAPS                    //
    ///////////////////////////////////////////////////////

    /**
     * @dev Executes a direct token swap at a fixed limit price without AMM pools.
     *
     * @dev    Throws when token transfer validation fails.
     *         Throws when hook validations fail.
     *         Throws when swap amount exceeds specified limit.
     *
     *         Performs direct token exchange between maker and taker using signed order parameters. Executes all
     *         applicable hooks but skips pool fee calculations. Transfers maker's desired output tokens from 
     *         executor (taker) to contract and validates balance changes. The maker's input tokens are transferred 
     *         to the taker during finalization.
     *
     *         <h4>Postconditions:</h4>
     *         1. Token settings retrieved for both input and output tokens
     *         2. Before and after swap hooks executed successfully  
     *         3. Hook fees processed and protocol fees accumulated
     *         4. Swap amount validated against limit parameters
     *         5. Taker's tokens transferred to contract with balance validation
     *         6. DirectSwap event emitted with operation details
     *
     * @param  swapOrder            Order details including tokens and limit amounts.
     * @param  directSwapParams     Direct swap parameters including swap amount and limits.
     * @param  swapCache            Swap operation context and state.
     * @param  swapHooksExtraData   Hook-specific data for all hook types.
     */
    function _directSwap(
        SwapOrder calldata swapOrder,
        DirectSwapParams calldata directSwapParams,
        InternalSwapCache memory swapCache,
        SwapHooksExtraData calldata swapHooksExtraData
    ) internal {
        TokenSettings memory tokenInSettings = Storage.appStorage().tokenSettings[swapCache.tokenIn];
        TokenSettings memory tokenOutSettings = Storage.appStorage().tokenSettings[swapCache.tokenOut];

        // Direct swap executor input is taken in the output token
        uint256 directSwapExecutorInput;
        if (swapCache.inputSwap) {
            swapCache.nextToken = swapCache.tokenOut;
            swapCache.amountOut = directSwapExecutorInput = directSwapParams.swapAmount;

            _executeBeforeSwapHooks(swapCache, tokenInSettings, tokenOutSettings, swapHooksExtraData);
            _applySwapByInputInputFees(swapCache, tokenInSettings, tokenOutSettings, 0);
            _executeAfterSwapHooks(swapCache, tokenInSettings, tokenOutSettings, swapHooksExtraData);
            _applySwapByInputOutputFees(swapCache, tokenInSettings, tokenOutSettings);
        } else {
            swapCache.nextToken = swapCache.tokenIn;
            swapCache.amountIn = directSwapParams.swapAmount;
            
            _executeBeforeSwapHooks(swapCache, tokenInSettings, tokenOutSettings, swapHooksExtraData);
            _applySwapByOutputOutputFees(swapCache, tokenInSettings, tokenOutSettings);
            _executeAfterSwapHooks(swapCache, tokenInSettings, tokenOutSettings, swapHooksExtraData);
            _applySwapByOutputInputFees(swapCache, tokenInSettings, tokenOutSettings, 0);

            directSwapExecutorInput = swapCache.amountOut;
        }

        if (directSwapExecutorInput > directSwapParams.maxAmountOut) {
            revert LBAMM__LimitAmountExceeded();
        }

        if (swapCache.protocolFee > 0) {
            swapCache.protocolFeeFromFees += swapCache.protocolFee;
        }

        if (msg.value > 0 && swapOrder.tokenOut == address(wrappedNative)) {
            _depositWrappedNativeAndRefundExcess(swapCache.context.executor, directSwapExecutorInput);
            swapCache.msgValueUsed = true;
        } else {
            _collectToken(swapCache.context.executor, swapOrder.tokenOut, directSwapExecutorInput);
        }

        emit DirectSwap(
            swapCache.context.executor,
            swapCache.context.recipient,
            swapOrder.tokenIn,
            swapOrder.tokenOut,
            swapCache.amountIn,
            swapCache.amountOut
        );
    }

    /**
     * @dev Completes direct swap by calculating and transferring maker's tokens to taker.
     *
     * @dev Throws when token transfer fails.
     *      Throws when taker receives less than minimum specified amount.
     *      Throws when swap finalization validation fails.
     *
     *      Captures token balances before and after shared finalization to determine the net amount
     *      of maker's tokens that should be transferred to the taker (executor). Validates that the
     *      taker receives at least the minimum specified amount and handles the final token transfer
     *      with special handling for wrapped native tokens.
     *
     *      <h4>Developer Notes:</h4>
     *      - Wrapped native tokens are unwrapped and sent as native value
     *
     *      <h4>Postconditions:</h4>
     *      1. Shared swap finalization logic executed successfully
     *      2. Net token amount calculated from balance changes
     *      3. Minimum amount validation completed
     *      4. Maker's tokens transferred to taker (executor)
     *      5. Wrapped native tokens unwrapped if applicable
     *
     * @param swapOrder         Order details including tokens and limit amounts
     * @param directSwapParams  Direct swap parameters including minimum amounts for taker
     * @param swapCache         Swap operation context and state tracking
     * @param exchangeFee       Exchange fee configuration for shared finalization
     * @param feeOnTop          Additional flat fee configuration for shared finalization
     * @param transferData      Custom transfer handler data for shared finalization
     */
    function _finalizeDirectSwap(
        SwapOrder calldata swapOrder,
        DirectSwapParams calldata directSwapParams,
        InternalSwapCache memory swapCache,
        BPSFeeWithRecipient calldata exchangeFee,
        FlatFeeWithRecipient calldata feeOnTop,
        bytes calldata transferData
    ) internal {
        uint256 tokenInToExecutor = _finalizeSwapCollectFundsAndDisburse(
            swapOrder,
            swapCache,
            exchangeFee,
            feeOnTop,
            transferData
        );

        tokenInToExecutor = tokenInToExecutor - swapCache.protocolFeeFromFees 
            - swapCache.tokenInTokenInFee - swapCache.tokenOutTokenInFee;

        if (tokenInToExecutor < directSwapParams.minAmountIn) {
            revert LBAMM__LimitAmountExceeded();
        }
        
        if (swapOrder.tokenIn == address(wrappedNative)) {
            wrappedNative.withdrawToAccount(swapCache.context.executor, tokenInToExecutor);
        } else {
            bool isError = SafeERC20.safeTransfer(swapOrder.tokenIn, swapCache.context.executor, tokenInToExecutor);
            if (isError) {
                revert LBAMM__TokenOutTransferFailed();
            }
        }
    }

    ///////////////////////////////////////////////////////
    //                      COMMON                       //
    ///////////////////////////////////////////////////////

    /**
     * @dev Validates that a pool with the given identifier exists and is initialized.
     *
     * @dev Throws when the pool has not been created or initialized.
     *
     * @param  poolId The identifier of the pool to validate.
     */
    function _requirePoolIsCreated(bytes32 poolId) internal view {
        if (!Storage.appStorage().poolInitialized[poolId]) {
            revert LBAMM__PoolDoesNotExist();
        }
    }

    /**
     * @dev Checks if a specific flag is set in a packed flag value using bitwise operations.
     *
     * @dev Uses bitwise AND operation to test if the specified flag bit is set in the flag value.
     *      Returns true if the flag is present, false otherwise.
     *
     * @param  flagValue The packed value containing multiple flags.
     * @param  flag      The specific flag bit to check.
     * @return flagSet   True if the flag is set, false otherwise.
     */
    function _isFlagSet(uint256 flagValue, uint256 flag) internal pure returns (bool flagSet) {
        flagSet = (flagValue & flag) != 0;
    }

    /**
     * @dev Validates that the provided deadline has not expired.
     *
     * @dev Throws when current block timestamp exceeds deadline.
     *
     *      Compares the deadline parameter against the current block timestamp to ensure the
     *      operation is still valid.
     *
     * @param  deadline The timestamp deadline for the operation.
     */
    function _validateDeadline(uint256 deadline) internal view {
        if (deadline < block.timestamp) {
            revert LBAMM__DeadlineExpired();
        }
    }

    /**
     * @dev Validates that the recipient address is not the zero address.
     *
     * @dev Throws when recipient address is zero.
     *
     *      Ensures that token transfers and other operations have a valid destination address.
     *
     * @param  recipient The address to validate as non-zero.
     */
    function _validateRecipient(address recipient) internal pure {
        if (recipient == address(0)) {
            revert LBAMM__RecipientCannotBeAddressZero();
        }
    }

    /**
     * @dev Validates exchange fee configuration.
     *
     * @dev Throws when exchange fee BPS is non-zero but recipient is zero.
     *
     *      Ensures that if an exchange fee is specified, there is a valid recipient address to
     *      receive the fee payment.
     *
     * @param  exchangeFee The exchange fee configuration including BPS rate and recipient.
     */
    function _validateExchangeFee(BPSFeeWithRecipient calldata exchangeFee) internal pure {
        if (exchangeFee.BPS > 0 && exchangeFee.recipient == address(0)) {
            revert LBAMM__FeeRecipientCannotBeAddressZero();
        }
    }

    /**
     * @dev Validates fee-on-top configuration.
     *
     * @dev Throws when fee amount is non-zero but recipient is zero.
     *
     *      Ensures that if a fee-on-top amount is specified, there is a valid recipient address
     *      to receive the fee payment.
     *
     * @param  feeOnTop The fee-on-top configuration including amount and recipient.
     */
    function _validateFeeOnTop(FlatFeeWithRecipient calldata feeOnTop) internal pure {
        if (feeOnTop.amount > 0 && feeOnTop.recipient == address(0)) {
            revert LBAMM__FeeRecipientCannotBeAddressZero();
        }
    }

    /**
     * @dev Initializes swap cache with order parameters and fee calculations.
     *
     * @dev Sets up swap context, determines swap direction, and pre-calculates fees for input-based swaps to ensure 
     *      sufficient input amounts are available.
     *
     * @param  swapOrder     Order parameters including tokens and amounts.
     * @param  swapCache     Memory structure to initialize with swap state.
     * @param  exchangeFee   Exchange fee configuration and recipient.
     * @param  feeOnTop      Additional flat fee configuration and recipient.
     * @param  transferData  Optional custom transfer handler data
     * @param  numberOfHops  Number of hops in the swap.
     */
    function _initializeSwapCache(
        SwapOrder calldata swapOrder,
        InternalSwapCache memory swapCache,
        BPSFeeWithRecipient calldata exchangeFee,
        FlatFeeWithRecipient calldata feeOnTop,
        bytes calldata transferData,
        uint256 numberOfHops
    ) internal view {
        address transferHandler;
        if (transferData.length >= 32) {
            assembly ("memory-safe") {
                transferHandler := calldataload(transferData.offset)
                if gt(shr(0xA0, transferHandler), 0) {
                    mstore(0x00, 0xd4ce1bc9) // LBAMM__InvalidTransferHandler()
                    revert(0x1C, 0x04)
                }
            }
        }

        swapCache.context = SwapContext({
            executor: msg.sender,
            transferHandler: transferHandler,
            exchangeFeeRecipient: exchangeFee.recipient,
            exchangeFeeBPS: exchangeFee.BPS,
            feeOnTopRecipient: feeOnTop.recipient,
            feeOnTopAmount: feeOnTop.amount,
            recipient: swapOrder.recipient,
            tokenIn: swapOrder.tokenIn,
            tokenOut: swapOrder.tokenOut,
            numberOfHops: numberOfHops
        });

        {
            swapCache.protocolFeeStructure = Storage.appStorage().protocolFeeStructure;
            ProtocolFeeOverride storage ptrFeeOverride = Storage.appStorage().exchangeProtocolFeeOverride[exchangeFee.recipient];
            if (ptrFeeOverride.feeOverrideEnabled) {
                swapCache.protocolFeeStructure.exchangeFeeBPS = ptrFeeOverride.protocolFeeBPS;
            }
            ptrFeeOverride = Storage.appStorage().feeOnTopProtocolFeeOverride[feeOnTop.recipient];
            if (ptrFeeOverride.feeOverrideEnabled) {
                swapCache.protocolFeeStructure.feeOnTopBPS = ptrFeeOverride.protocolFeeBPS;
            }
            swapCache.defaultProtocolLPFeeBPS = swapCache.protocolFeeStructure.lpFeeBPS;
        }

        swapCache.inputSwap = swapOrder.amountSpecified > 0;
        swapCache.minAmountSpecified = swapOrder.minAmountSpecified;

        // Fees are taken from the token in, so we calculate them before any swaps happen.
        if (swapCache.inputSwap) {
            swapCache.adjustedAmountSpecified = uint256(swapOrder.amountSpecified);
            swapCache.nextToken = swapOrder.tokenIn;
            swapCache.amountIn = uint256(swapOrder.amountSpecified);
            FeeHelper.calculateAmountAfterFeesSwapByInput(
                swapCache, exchangeFee, feeOnTop, swapCache.protocolFeeStructure
            );
        } else {
            swapCache.adjustedAmountSpecified = uint256(-swapOrder.amountSpecified);
            swapCache.nextToken = swapOrder.tokenOut;
            swapCache.amountOut = uint256(-swapOrder.amountSpecified);
        }
    }

    /**
     * @dev Completes swap by collecting input tokens and distributing output tokens and fees.
     *
     * @dev Throws when pool routing validation fails.
     *      Throws when price limit validation fails.
     *      Throws when token transfer operations fail.
     *      Throws when executor payment validation fails.
     *      Throws when native value sent but not used for wrapped native operations.
     *
     *      Validates swap completion requirements, handles wrapped native deposits/withdrawals, processes transfers 
     *      through custom handlers if specified, and distributes fees to designated recipients. This function serves
     *      as the shared finalization logic for both pool swaps and direct swaps.
     *
     *      <h4>Developer Notes:</h4>
     *      - Uses custom transfer handlers when transferData length >= 32
     *      - Handles wrapped native deposits and withdrawals automatically
     *      - Processes all fee types: exchange fees, fees-on-top, and protocol fees
     *
     *      <h4>Postconditions:</h4>
     *      1. Swap completion requirements validated (routing and limits)
     *      2. Input tokens collected from executor with balance validation
     *      3. Output tokens distributed to recipient
     *      4. Exchange fees transferred to designated recipient
     *      5. Fees-on-top transferred to designated recipient
     *      6. Protocol fees stored for later collection
     *      7. Excess native value refunded to executor if applicable
     *
     * @param swapOrder     Original swap order parameters including tokens and limits
     * @param swapCache     Completed swap state with final amounts and fees
     * @param exchangeFee   Exchange fee configuration and recipient
     * @param feeOnTop      Additional flat fee configuration and recipient
     * @param transferData  Optional custom transfer handler data
     * 
     * @return netAmountIn  Amount of input token after fees.
     */
    function _finalizeSwapCollectFundsAndDisburse(
        SwapOrder calldata swapOrder,
        InternalSwapCache memory swapCache,
        BPSFeeWithRecipient calldata exchangeFee,
        FlatFeeWithRecipient calldata feeOnTop,
        bytes calldata transferData
    ) internal returns (uint256 netAmountIn) {
        if (swapCache.inputSwap) {
            if (swapCache.nextToken != swapOrder.tokenOut) {
                revert LBAMM__InvalidPoolId();
            }

            if (swapCache.amountOut < swapOrder.limitAmount) {
                revert LBAMM__LimitAmountNotMet();
            }

            swapCache.amountIn = swapCache.adjustedAmountSpecified;
        } else {
            if (swapCache.nextToken != swapOrder.tokenIn) {
                revert LBAMM__InvalidPoolId();
            }

            swapCache.amountOut = swapCache.adjustedAmountSpecified;
            FeeHelper.calculateAmountAfterFeesSwapByOutput(
                swapCache, feeOnTop, exchangeFee, swapCache.protocolFeeStructure
            );

            if (swapCache.amountIn > swapOrder.limitAmount) {
                revert LBAMM__LimitAmountExceeded();
            }
        }

        if (swapCache.protocolFeeFromFees > 0) {
            _storeProtocolFees(swapOrder.tokenIn, swapCache.protocolFeeFromFees);
        }

        uint256 balanceInBefore = IERC20(swapOrder.tokenIn).balanceOf(address(this));

        address transferHandler;
        if (msg.value > 0 && !swapCache.msgValueUsed) {
            if (swapOrder.tokenIn != address(wrappedNative)) {
                revert LBAMM__InputNotWrappedNative();
            }
            _depositWrappedNativeAndRefundExcess(swapCache.context.executor, swapCache.amountIn);
        } else {
            transferHandler = swapCache.context.transferHandler;
            if (transferHandler == address(0)) {
                SafeERC20.safeTransferFrom(swapOrder.tokenIn, swapCache.context.executor, address(this), swapCache.amountIn);
            } else {
                (transferHandler, swapCache.callbackMemoryPointer) = _executeTransferHandler(
                    swapCache.context.executor,
                    swapOrder,
                    swapCache.amountIn,
                    swapCache.amountOut,
                    exchangeFee,
                    feeOnTop,
                    transferData[32:],
                    transferHandler
                );
            }
        }

        {
            uint256 balanceInAfter = IERC20(swapOrder.tokenIn).balanceOf(address(this));
            if (balanceInBefore + swapCache.amountIn != balanceInAfter) {
                revert LBAMM__TokenInTransferFailed();
            }
            unchecked {
                netAmountIn = balanceInAfter - balanceInBefore; 
            }
        }

        {
            uint256 exchangeFeeAmount = swapCache.exchangeFeeAmount;
            if (exchangeFeeAmount > 0) {
                bool isError = SafeERC20.safeTransfer(swapOrder.tokenIn, exchangeFee.recipient, exchangeFeeAmount);
                if (isError) {
                    revert LBAMM__ExchangeFeeTransferFailed();
                }
                netAmountIn -= exchangeFeeAmount;
            }
            uint256 feeOnTopAmount = swapCache.feeOnTopAmount;
            if (feeOnTopAmount > 0) {
                bool isError = SafeERC20.safeTransfer(swapOrder.tokenIn, feeOnTop.recipient, feeOnTopAmount);
                if (isError) {
                    revert LBAMM__FeeOnTopTransferFailed();
                }
                netAmountIn -= feeOnTopAmount;
            }
        }

        if (swapCache.amountOut > 0) {
            if (swapOrder.tokenOut == address(wrappedNative)) {
                wrappedNative.withdrawToAccount(swapCache.context.recipient, swapCache.amountOut);
            } else {
                bool isError = SafeERC20.safeTransfer(swapOrder.tokenOut, swapCache.context.recipient, swapCache.amountOut);
                if (isError) {
                    revert LBAMM__TokenOutTransferFailed();
                }
            }
        }

        if (_queuedHookFeesByHookTransfers() > 0) {
            ILimitBreakAMM(address(this)).executeQueuedHookFeesByHookTransfers();
        }

        if (transferHandler != address(0)) {
            _executeTransferHandlerCallback(transferHandler, swapCache.callbackMemoryPointer);
        }
    }

    /**
     * @notice  Calls the transfer handler's handle transfer function to retrieve input tokens for the swap.
     * 
     * @dev     Function is optimized in assembly.
     * 
     * @param executor         Address of the order executor.
     * @param swapOrder        Original swap order parameters including tokens and limits.
     * @param amountIn         Amount of input tokens required for the order.
     * @param amountOut        Amount of output tokens that will be filled on the order.
     * @param exchangeFee      Exchange fee configuration and recipient.
     * @param feeOnTop         Additional flat fee configuration and recipient.
     * @param transferData     Calldata to pass to the transfer handler.
     * @param transferHandler  Address of the transfer handler to call for execution.
     * 
     * @return callbackTransferHandler  Clears the transfer handler address if no callback data is specified.
     * @return callbackMemoryPointer    Memory pointer to where handler callback data is stored.
     */
    function _executeTransferHandler(
        address executor,
        SwapOrder calldata swapOrder,
        uint256 amountIn,
        uint256 amountOut,
        BPSFeeWithRecipient calldata exchangeFee,
        FlatFeeWithRecipient calldata feeOnTop,
        bytes calldata transferData,
        address transferHandler
    ) internal returns (address callbackTransferHandler, uint256 callbackMemoryPointer) {
        bytes4 functionSelector = ILimitBreakAMMTransferHandler.ammHandleTransfer.selector;
        uint256 dataLength = _addAdjustedBytesLength(TRANSFER_HANDLER_ALLOCATION_BASE, transferData.length);
        assembly ("memory-safe") {
            mstore(0x00, 0x00)
            let ptr := mload(0x40)
            mstore(0x40, add(ptr, dataLength))
            mstore(ptr, shr(0xE0, functionSelector))
            mstore(add(ptr, 0x20), executor)
            calldatacopy(add(ptr, 0x40), swapOrder, 0xE0)
            mstore(add(ptr, 0x120), amountIn)
            mstore(add(ptr, 0x140), amountOut)
            calldatacopy(add(ptr, 0x160), exchangeFee, 0x40)
            calldatacopy(add(ptr, 0x1A0), feeOnTop, 0x40)
            mstore(add(ptr, 0x1E0), 0x1E0)
            let transferDataLength := transferData.length
            let transferDataCopyLength := and(not(0x1F), add(transferDataLength, 0x1F))
            mstore(add(ptr, 0x200), transferDataLength)
            calldatacopy(add(ptr, 0x220), transferData.offset, transferDataCopyLength)

            let success := call(gas(), transferHandler, 0, add(0x1C, ptr), add(0x204, transferDataCopyLength), 0x00, 0x00)
            if gt(returndatasize(), dataLength) {
                mstore(0x40, add(ptr, returndatasize()))
            }
            returndatacopy(ptr, 0x00, returndatasize())
            if iszero(success) {
                revert(ptr, returndatasize())
            }

            let offset := mload(ptr)
            if gt(offset, returndatasize()) {
                revert(0x00, 0x00) // panic, invalid return
            }
            callbackMemoryPointer := add(ptr, offset)
            let length := mload(callbackMemoryPointer)
            if or(gt(length, 0xFFFFFFFF), gt(add(add(offset, length), 0x20), returndatasize())) {
                revert(0x00, 0x00) // panic, invalid return
            }
            callbackTransferHandler := mul(transferHandler, gt(length, 0x00))
        }
    }

    /**
     * @notice  Calls back to the transfer handler after swap finalization using data supplied by
     *          the transfer handler.
     * 
     * @param transferHandler        Address of the transfer handler to callback.
     * @param callbackMemoryPointer  Memory pointer for the callback data.
     */
    function _executeTransferHandlerCallback(
        address transferHandler,
        uint256 callbackMemoryPointer
    ) internal {
        assembly ("memory-safe") {
            let success := call(gas(), transferHandler, 0, add(callbackMemoryPointer, 0x20), mload(callbackMemoryPointer), 0x00, 0x00)
            if iszero(success) {
                returndatacopy(0x00, 0x00, returndatasize())
                revert(0x00, returndatasize())
            }
        }
    }

    /**
     * @dev Executes before-swap hooks for input and output tokens and sets executor payer requirements.
     *
     * @dev Throws when hook execution fails.
     *
     *      Executes before-swap hooks for both tokens if enabled, collecting any hook fees. Stores fees
     *      in appropriate swap cache fields based on input/output-based mode for later processing.
     *
     *      <h4>Postconditions:</h4>
     *      1. Executor payer requirement flag updated based on token settings
     *      2. Before-swap hooks executed for tokens with flags enabled
     *
     * @param  swapCache          Swap operation context and state tracking.
     * @param  tokenInSettings    Input token configuration including hook settings.
     * @param  tokenOutSettings   Output token configuration including hook settings.
     * @param  swapHooksExtraData Hook-specific data for token hooks.
     */
    function _executeBeforeSwapHooks(
        InternalSwapCache memory swapCache,
        TokenSettings memory tokenInSettings,
        TokenSettings memory tokenOutSettings,
        SwapHooksExtraData calldata swapHooksExtraData
    ) internal {
        uint256 tokenInHookFee;
        uint256 tokenOutHookFee;
        uint256 swapAmount = swapCache.inputSwap ? swapCache.amountIn : swapCache.amountOut;

        if (_isFlagSet(tokenInSettings.packedSettings, TOKEN_SETTINGS_BEFORE_SWAP_HOOK_FLAG)) {
            tokenInHookFee = _executeSwapHook(
                ILimitBreakAMMTokenHook.beforeSwap.selector,
                swapCache,
                true,
                swapAmount,
                swapHooksExtraData.tokenInHook,
                tokenInSettings.tokenHook
            );
        }

        if (_isFlagSet(tokenOutSettings.packedSettings, TOKEN_SETTINGS_BEFORE_SWAP_HOOK_FLAG)) {
            tokenOutHookFee = _executeSwapHook(
                ILimitBreakAMMTokenHook.beforeSwap.selector,
                swapCache,
                false,
                swapAmount,
                swapHooksExtraData.tokenOutHook,
                tokenOutSettings.tokenHook
            );
        }

        if (swapCache.inputSwap) {
            swapCache.tokenInTokenInFee = tokenInHookFee;
            swapCache.tokenOutTokenInFee = tokenOutHookFee;
        } else {
            swapCache.tokenInTokenOutFee = tokenInHookFee;
            swapCache.tokenOutTokenOutFee = tokenOutHookFee;
        }
    }

    /**
     * @dev Executes after-swap hooks for input and output tokens.
     *
     * @dev Throws when hook execution fails.
     *
     *      Executes after-swap hooks for both tokens if enabled, collecting any hook fees. Stores fees
     *      in appropriate swap cache fields based on input/output-based mode for final fee processing.
     *
     *      <h4>Postconditions:</h4>
     *      1. After-swap hooks executed for tokens with flags enabled
     *
     * @param  swapCache          Swap operation context and state tracking.
     * @param  tokenInSettings    Input token configuration including hook settings.
     * @param  tokenOutSettings   Output token configuration including hook settings.
     * @param  swapHooksExtraData Hook-specific data for token hooks.
     */
    function _executeAfterSwapHooks(
        InternalSwapCache memory swapCache,
        TokenSettings memory tokenInSettings,
        TokenSettings memory tokenOutSettings,
        SwapHooksExtraData calldata swapHooksExtraData
    ) internal {
        uint256 tokenInHookFee;
        uint256 tokenOutHookFee;
        uint256 swapAmount = swapCache.inputSwap ? swapCache.amountOut : swapCache.amountIn;

        if (_isFlagSet(tokenInSettings.packedSettings, TOKEN_SETTINGS_AFTER_SWAP_HOOK_FLAG)) {
            tokenInHookFee = _executeSwapHook(
                ILimitBreakAMMTokenHook.afterSwap.selector,
                swapCache,
                true,
                swapAmount,
                swapHooksExtraData.tokenInHook,
                tokenInSettings.tokenHook
            );
        }

        if (_isFlagSet(tokenOutSettings.packedSettings, TOKEN_SETTINGS_AFTER_SWAP_HOOK_FLAG)) {
            tokenOutHookFee = _executeSwapHook(
                ILimitBreakAMMTokenHook.afterSwap.selector,
                swapCache,
                false,
                swapAmount,
                swapHooksExtraData.tokenOutHook,
                tokenOutSettings.tokenHook
            );
        }

        if (swapCache.inputSwap) {
            swapCache.tokenInTokenOutFee = tokenInHookFee;
            swapCache.tokenOutTokenOutFee = tokenOutHookFee;
        } else {
            swapCache.tokenInTokenInFee = tokenInHookFee;
            swapCache.tokenOutTokenInFee = tokenOutHookFee;
        }
    }

    /**
     * @dev Executes a token swap hook using optimized assembly for efficient memory management.
     *
     * @dev Throws when hook call fails or reverts.
     *
     *      Uses pre-allocated hook memory to construct call data with swap context, token information,
     *      amounts, and hook-specific data. Executes external call with gas forwarding and processes
     *      return value to extract optional fee amount.
     *
     *      <h4>Developer Notes:</h4>
     *      - Assembly optimized call data construction with 0x1C offset to create properly formatted call data
     *      - Hook data padded to 32-byte boundaries for efficient memory operations
     *      - Return data size of 0x20 (32 bytes) represents the uint256 fee amount provided by hook
     *
     *      <h4>Postconditions:</h4>
     *      1. Hook memory allocated if not already available
     *      2. External hook contract called with structured data
     *      3. Hook fee amount extracted from return data if provided
     *
     * @param  functionSelector   The function selector to call on the hook contract.
     * @param  swapCache          Swap operation context and state.
     * @param  hookForInputToken  Whether hook is for input or output token.
     * @param  amount             The token amount being processed.
     * @param  hookData           Hook-specific calldata.
     * @param  hook               Address of the hook contract to call.
     * @return feeAmount          Fee amount returned by the hook, zero if not provided.
     */
    function _executeSwapHook(
        bytes4 functionSelector,
        InternalSwapCache memory swapCache,
        bool hookForInputToken,
        uint256 amount,
        bytes calldata hookData,
        address hook
    ) internal returns (uint256 feeAmount) {
        uint256 hookMemoryPointer = swapCache.hookMemoryPointer;
        if (hookMemoryPointer == 0) {
            hookMemoryPointer = swapCache.hookMemoryPointer = _allocateHookMemory(swapCache);
        }

        uint256 hopIndex = swapCache.hopIndex;
        bytes32 poolId = swapCache.poolId;
        address tokenIn = swapCache.tokenIn;
        address tokenOut = swapCache.tokenOut;
        assembly ("memory-safe") {
            mstore(hookMemoryPointer, shr(0xE0, functionSelector))
            mstore(add(hookMemoryPointer, 0x180), hopIndex)
            mstore(add(hookMemoryPointer, 0x1A0), poolId)
            mstore(add(hookMemoryPointer, 0x1C0), tokenIn)
            mstore(add(hookMemoryPointer, 0x1E0), tokenOut)
            mstore(add(hookMemoryPointer, 0x200), amount)
            mstore(add(hookMemoryPointer, 0x220), hookForInputToken)
            mstore(add(hookMemoryPointer, 0x240), 0x240)
            let hookDataLength := hookData.length
            let hookDataCopyLength := and(not(0x1F), add(hookDataLength, 0x1F))
            mstore(add(hookMemoryPointer, 0x260), hookDataLength)
            calldatacopy(add(hookMemoryPointer, 0x280), hookData.offset, hookDataCopyLength)

            let success :=
                call(gas(), hook, 0x00, add(hookMemoryPointer, 0x1C), add(0x264, hookDataCopyLength), 0x00, 0x20)
            if iszero(success) {
                returndatacopy(0x00, 0x00, returndatasize())
                revert(0x00, returndatasize())
            }
            if eq(returndatasize(), 0x20) { feeAmount := mload(0x00) }
        }
    }

    /**
     * @dev Allocates and initializes memory for efficient hook call data construction.
     *
     * @dev Uses assembly to allocate memory and populate swap context data for hook calls. Calculates
     *      required memory size based on longest hook data length to avoid reallocation during swaps.
     *
     *      <h4>Postconditions:</h4>
     *      1. Memory allocated and free memory pointer updated
     *      2. Swap context data populated in allocated memory
     *
     * @param  swapCache           Swap operation context containing caller and token information.
     * @return hookMemoryPointer   Pointer to allocated and initialized hook memory.
     */
    function _allocateHookMemory(InternalSwapCache memory swapCache)
        internal
        pure
        returns (uint256 hookMemoryPointer)
    {
        SwapContext memory context = swapCache.context;
        uint256 dataLength = _addAdjustedBytesLength(HOOK_ALLOCATION_BASE, swapCache.hookLongestData);
        address executor = context.executor;
        address transferHandler = context.transferHandler;
        address exchangeFeeRecipient = context.exchangeFeeRecipient;
        uint256 exchangeFeeBPS = context.exchangeFeeBPS;
        address feeOnTopRecipient = context.feeOnTopRecipient;
        uint256 feeOnTopAmount = context.feeOnTopAmount;
        address recipient = context.recipient;
        address tokenIn = context.tokenIn;
        address tokenOut = context.tokenOut;
        uint256 numberOfHops = context.numberOfHops;
        bool inputSwap = swapCache.inputSwap;
        assembly ("memory-safe") {
            hookMemoryPointer := mload(0x40)
            mstore(0x40, add(hookMemoryPointer, dataLength))
            mstore(add(hookMemoryPointer, 0x20), executor)
            mstore(add(hookMemoryPointer, 0x40), transferHandler)
            mstore(add(hookMemoryPointer, 0x60), exchangeFeeRecipient)
            mstore(add(hookMemoryPointer, 0x80), exchangeFeeBPS)
            mstore(add(hookMemoryPointer, 0xA0), feeOnTopRecipient)
            mstore(add(hookMemoryPointer, 0xC0), feeOnTopAmount)
            mstore(add(hookMemoryPointer, 0xE0), recipient)
            mstore(add(hookMemoryPointer, 0x100), tokenIn)
            mstore(add(hookMemoryPointer, 0x120), tokenOut)
            mstore(add(hookMemoryPointer, 0x140), numberOfHops)
            mstore(add(hookMemoryPointer, 0x160), inputSwap)
        }
    }

    /**
     * @dev Applies hook fees and minimum protocol fees for input-based swaps.
     *
     * @dev Throws when insufficient input amount to cover hook fees.
     *      Throws when arithmetic operations overflow.
     *
     *      Processes input token hook fees by deducting from swap amount and calculating protocol
     *      portions. Ensures minimum protocol fee requirements are met by adding additional protocol
     *      fees if needed. Stores hook fees appropriately and updates swap cache with final amounts.
     *
     *      <h4>Postconditions:</h4>
     *      1. Hook fees deducted from swap input amount
     *      2. Protocol portions of hook fees calculated and accumulated
     *      3. Additional protocol fees added if minimum not met
     *      4. Hook fees stored for later distribution
     *      5. Final swap amounts and protocol fees updated in cache
     *      6. tokensOwed mappings updated for hook fee storage keys
     *      7. protocolFee accumulated with hook fees and minimum enforcement amounts
     *
     * @param  swapCache        Swap operation context and fee tracking.
     * @param  poolFeeBPS       Pool fee rate for LP fee calculations.
     * @param  tokenInSettings  Input token configuration including hop fee settings.
     * @param  tokenOutSettings Output token configuration including hop fee settings.
     */
    function _applySwapByInputInputFees(
        InternalSwapCache memory swapCache,
        TokenSettings memory tokenInSettings,
        TokenSettings memory tokenOutSettings,
        uint16 poolFeeBPS
    ) internal {
        uint16 inputTokenHopFeeBPS = tokenInSettings.hopFeeBPS;
        uint256 swapAmountIn = swapCache.amountIn;

        uint256 minimumProtocolFee;
        if (inputTokenHopFeeBPS > 0) {
            minimumProtocolFee = FullMath.mulDiv(swapAmountIn, inputTokenHopFeeBPS, MAX_BPS);
        }

        uint256 protocolFeeFromHookFees;
        unchecked {
            uint256 feeAmount = swapCache.tokenInTokenInFee;
            if (feeAmount != 0) {
                if (feeAmount > swapAmountIn) {
                    revert LBAMM__InsufficientInputForFees();
                }
                swapAmountIn -= feeAmount;
                if (inputTokenHopFeeBPS > 0) {
                    protocolFeeFromHookFees = FullMath.mulDiv(feeAmount, inputTokenHopFeeBPS, MAX_BPS);
                    feeAmount -= protocolFeeFromHookFees;
                    swapCache.tokenInTokenInFee = feeAmount;
                }
                _storeHookFees(swapCache.tokenIn, swapCache.tokenIn, tokenInSettings, feeAmount);
            }
            feeAmount = swapCache.tokenOutTokenInFee;
            if (feeAmount != 0) {
                if (feeAmount > swapAmountIn) {
                    revert LBAMM__InsufficientInputForFees();
                }
                swapAmountIn -= feeAmount;
                if (inputTokenHopFeeBPS > 0) {
                    uint256 protocolFeeOfHookFee = FullMath.mulDiv(feeAmount, inputTokenHopFeeBPS, MAX_BPS);
                    feeAmount -= protocolFeeOfHookFee;
                    swapCache.tokenOutTokenInFee = feeAmount;
                    protocolFeeFromHookFees += protocolFeeOfHookFee;
                    if (protocolFeeFromHookFees < protocolFeeOfHookFee) {
                        revert LBAMM__Overflow();
                    }
                }
                _storeHookFees(swapCache.tokenOut, swapCache.tokenIn, tokenOutSettings, feeAmount);
            }
        }
        
        uint256 expectedLPFee = FullMath.mulDivRoundingUp(swapAmountIn, poolFeeBPS, MAX_BPS);
        uint256 expectedProtocolLPFee = FullMath.mulDiv(
            expectedLPFee,
            swapCache.protocolFeeStructure.lpFeeBPS,
            MAX_BPS
        );
        if (protocolFeeFromHookFees + expectedProtocolLPFee < minimumProtocolFee) {
            uint256 shortage;
            uint256 protocolFeeFromInput;
            unchecked {
                shortage = minimumProtocolFee - expectedProtocolLPFee - protocolFeeFromHookFees;
                protocolFeeFromInput = FullMath.mulDivRoundingUp(
                    shortage,
                    DOUBLE_BPS,
                    (DOUBLE_BPS - uint256(poolFeeBPS) * uint256(swapCache.protocolFeeStructure.lpFeeBPS))
                );
            }
            swapAmountIn -= protocolFeeFromInput;
            expectedLPFee = FullMath.mulDivRoundingUp(swapAmountIn, poolFeeBPS, MAX_BPS);
            expectedProtocolLPFee = FullMath.mulDiv(
                expectedLPFee,
                swapCache.protocolFeeStructure.lpFeeBPS,
                MAX_BPS
            );
            protocolFeeFromHookFees += protocolFeeFromInput;
        }

        swapCache.amountIn = swapAmountIn;
        swapCache.expectedLPFee = expectedLPFee;
        swapCache.expectedProtocolLPFee = expectedProtocolLPFee;
        swapCache.protocolFee = protocolFeeFromHookFees;
    }

    /**
     * @dev Applies hook fees for input-based swaps on output amounts.
     *
     * @dev Throws when insufficient output amount to cover hook fees.
     *      Throws when arithmetic operations overflow.
     *
     *      Processes output token hook fees by deducting from swap output amount and calculating
     *      protocol portions. Stores hook fees and protocol fees appropriately.
     *
     *      <h4>Postconditions:</h4>
     *      1. Hook fees deducted from swap output amount
     *      2. Protocol portions of hook fees calculated
     *      3. Hook fees stored for later distribution
     *      4. Protocol fees stored if applicable
     *      5. Final output amount updated in cache
     *
     * @param  swapCache        Swap operation context and fee tracking.
     * @param  tokenInSettings  Input token configuration including hop fee settings.
     * @param  tokenOutSettings Output token configuration including hop fee settings.
     */
    function _applySwapByInputOutputFees(
        InternalSwapCache memory swapCache,
        TokenSettings memory tokenInSettings,
        TokenSettings memory tokenOutSettings
    ) internal {
        uint16 outputTokenHopFeeBPS = tokenOutSettings.hopFeeBPS;
        uint256 swapAmountOut = swapCache.amountOut;

        uint256 outputProtocolFeeFromHookFees;
        unchecked {
            uint256 feeAmount = swapCache.tokenInTokenOutFee;
            if (feeAmount != 0) {
                if (feeAmount > swapAmountOut) {
                    revert LBAMM__InsufficientOutputForFees();
                }
                swapAmountOut -= feeAmount;
                if (outputTokenHopFeeBPS > 0) {
                    outputProtocolFeeFromHookFees = FullMath.mulDiv(feeAmount, outputTokenHopFeeBPS, MAX_BPS);
                    feeAmount -= outputProtocolFeeFromHookFees;
                }
                _storeHookFees(swapCache.tokenIn, swapCache.tokenOut, tokenInSettings, feeAmount);
            }
            feeAmount = swapCache.tokenOutTokenOutFee;
            if (feeAmount != 0) {
                if (feeAmount > swapAmountOut) {
                    revert LBAMM__InsufficientOutputForFees();
                }
                swapAmountOut -= feeAmount;
                if (outputTokenHopFeeBPS > 0) {
                    uint256 protocolFeeOfHookFee = FullMath.mulDiv(feeAmount, outputTokenHopFeeBPS, MAX_BPS);
                    feeAmount -= protocolFeeOfHookFee;
                    outputProtocolFeeFromHookFees += protocolFeeOfHookFee;
                    if (outputProtocolFeeFromHookFees < protocolFeeOfHookFee) {
                        revert LBAMM__Overflow();
                    }
                }
                _storeHookFees(swapCache.tokenOut, swapCache.tokenOut, tokenOutSettings, feeAmount);
            }
        }
        if (outputProtocolFeeFromHookFees > 0) {
            _storeProtocolFees(swapCache.tokenOut, outputProtocolFeeFromHookFees);
        }

        swapCache.amountOut = swapAmountOut;
    }

    /**
     * @dev Applies hook fees and minimum protocol fees for output-based swaps on input amounts.
     *
     * @dev Throws when arithmetic operations overflow.
     *
     *      Processes input token hook fees by adding to swap amount and calculating protocol portions.
     *      Ensures minimum protocol fee requirements are met by adding additional protocol fees if
     *      needed. Stores hook fees appropriately and updates swap cache with final amounts.
     *
     *      <h4>Postconditions:</h4>
     *      1. Hook fees added to swap input amount
     *      2. Protocol portions of hook fees calculated and accumulated
     *      3. Additional protocol fees added if minimum not met
     *      4. Hook fees stored for later distribution
     *      5. Final swap amounts and protocol fees updated in cache
     *
     * @param  swapCache           Swap operation context and fee tracking.
     * @param  tokenInSettings     Input token configuration including hop fee settings.
     * @param  tokenOutSettings    Output token configuration including hop fee settings.
     * @param  actualProtocolLPFee Actual protocol LP fee amount for minimum calculations.
     */
    function _applySwapByOutputInputFees(
        InternalSwapCache memory swapCache,
        TokenSettings memory tokenInSettings,
        TokenSettings memory tokenOutSettings,
        uint256 actualProtocolLPFee
    ) internal {
        uint16 inputTokenHopFeeBPS = tokenInSettings.hopFeeBPS;
        uint256 swapAmountIn = swapCache.amountIn;

        uint256 minimumProtocolFee;
        if (inputTokenHopFeeBPS > 0) {
            minimumProtocolFee = FullMath.mulDiv(swapAmountIn, inputTokenHopFeeBPS, MAX_BPS);
        }

        uint256 protocolFeeFromHookFees;
        unchecked {
            uint256 feeAmount = swapCache.tokenInTokenInFee;
            if (feeAmount != 0) {
                swapAmountIn += feeAmount;
                if (swapAmountIn < feeAmount) {
                    revert LBAMM__Overflow();
                }
                if (inputTokenHopFeeBPS > 0) {
                    protocolFeeFromHookFees = FullMath.mulDiv(feeAmount, inputTokenHopFeeBPS, MAX_BPS);
                    feeAmount -= protocolFeeFromHookFees;
                    swapCache.tokenInTokenInFee = feeAmount;
                }
                _storeHookFees(swapCache.tokenIn, swapCache.tokenIn, tokenInSettings, feeAmount);
            }
            feeAmount = swapCache.tokenOutTokenInFee;
            if (feeAmount != 0) {
                swapAmountIn += feeAmount;
                if (swapAmountIn < feeAmount) {
                    revert LBAMM__Overflow();
                }
                if (inputTokenHopFeeBPS > 0) {
                    uint256 protocolFeeOfHookFee = FullMath.mulDiv(feeAmount, inputTokenHopFeeBPS, MAX_BPS);
                    feeAmount -= protocolFeeOfHookFee;
                    protocolFeeFromHookFees += protocolFeeOfHookFee;
                    if (protocolFeeFromHookFees < protocolFeeOfHookFee) {
                        revert LBAMM__Overflow();
                    }
                    swapCache.tokenOutTokenInFee = feeAmount;
                }
                _storeHookFees(swapCache.tokenOut, swapCache.tokenIn, tokenOutSettings, feeAmount);
            }
        }
        if (protocolFeeFromHookFees + actualProtocolLPFee < minimumProtocolFee) {
            uint256 shortage;
            uint256 protocolFeeFromInput;
            unchecked {
                shortage = minimumProtocolFee - actualProtocolLPFee - protocolFeeFromHookFees;
                protocolFeeFromInput = FullMath.mulDivRoundingUp(
                    shortage,
                    MAX_BPS,
                    (MAX_BPS - inputTokenHopFeeBPS)
                );
            }
            swapAmountIn += protocolFeeFromInput;
            protocolFeeFromHookFees += protocolFeeFromInput;
        }

        swapCache.amountIn = swapAmountIn;
        swapCache.protocolFee = protocolFeeFromHookFees;
    }

    /**
     * @dev Applies hook fees for output-based swaps on output amounts.
     *
     * @dev Throws when arithmetic operations overflow.
     *
     *      Processes output token hook fees by adding to swap output amount and calculating protocol
     *      portions. Stores hook fees and protocol fees appropriately for later distribution.
     *
     *      <h4>Postconditions:</h4>
     *      1. Hook fees added to swap output amount
     *      2. Protocol portions of hook fees calculated
     *      3. Hook fees stored for later distribution
     *      4. Protocol fees stored if applicable
     *      5. Final output amount updated in cache
     *
     * @param  swapCache        Swap operation context and fee tracking.
     * @param  tokenInSettings  Input token configuration including hop fee settings.
     * @param  tokenOutSettings Output token configuration including hop fee settings.
     */
    function _applySwapByOutputOutputFees(
        InternalSwapCache memory swapCache,
        TokenSettings memory tokenInSettings,
        TokenSettings memory tokenOutSettings
    ) internal {
        uint16 outputTokenHopFeeBPS = tokenOutSettings.hopFeeBPS;
        uint256 swapAmountOut = swapCache.amountOut;

        uint256 outputProtocolFeeFromHookFees;
        unchecked {
            uint256 feeAmount = swapCache.tokenInTokenOutFee;
            if (feeAmount != 0) {
                swapAmountOut += feeAmount;
                if (swapAmountOut < feeAmount) {
                    revert LBAMM__Overflow();
                }
                if (outputTokenHopFeeBPS > 0) {
                    outputProtocolFeeFromHookFees = FullMath.mulDiv(feeAmount, outputTokenHopFeeBPS, MAX_BPS);
                    feeAmount -= outputProtocolFeeFromHookFees;
                }
                _storeHookFees(swapCache.tokenIn, swapCache.tokenOut, tokenInSettings, feeAmount);
            }
            feeAmount = swapCache.tokenOutTokenOutFee;
            if (feeAmount != 0) {
                swapAmountOut += feeAmount;
                if (swapAmountOut < feeAmount) {
                    revert LBAMM__Overflow();
                }
                if (outputTokenHopFeeBPS > 0) {
                    uint256 protocolFeeOfHookFee = FullMath.mulDiv(feeAmount, outputTokenHopFeeBPS, MAX_BPS);
                    feeAmount -= protocolFeeOfHookFee;
                    outputProtocolFeeFromHookFees += protocolFeeOfHookFee;
                    if (outputProtocolFeeFromHookFees < protocolFeeOfHookFee) {
                        revert LBAMM__Overflow();
                    }
                }
                _storeHookFees(swapCache.tokenOut, swapCache.tokenOut, tokenOutSettings, feeAmount);
            }
        }
        if (outputProtocolFeeFromHookFees > 0) {
            _storeProtocolFees(swapCache.tokenOut, outputProtocolFeeFromHookFees);
        }

        swapCache.amountOut = swapAmountOut;
    }

    /**
     * @dev Collects tokens from provider with balance validation.
     *
     * @dev Throws when token transfer fails or balance validation fails.
     *
     *      Performs safe transfer from provider to contract and validates balance changes match
     *      expected amounts to ensure transfer completed successfully.
     *
     *      <h4>Postconditions:</h4>
     *      1. Tokens transferred from provider to contract
     *      2. Balance changes validated
     *
     * @param  provider Address providing the tokens.
     * @param  token    Token address being collected.
     * @param  amount   Amount of tokens to collect.
     */
    function _collectToken(address provider, address token, uint256 amount) internal {
        if (amount == 0) return;
        uint256 balanceBefore = IERC20(token).balanceOf(address(this));
        SafeERC20.safeTransferFrom(token, provider, address(this), amount);
        if (IERC20(token).balanceOf(address(this)) != balanceBefore + amount) {
            revert LBAMM__TokenInTransferFailed();
        }
    }

    /**
     * @dev Stores tokens owed to an address using efficient hash-based storage.
     *
     * @dev  Throws when addition would cause overflow.
     *
     *      Uses efficient hash of addresses to create storage key and safely accumulates owed amounts
     *      with overflow protection.
     *
     *      <h4>Postconditions:</h4>
     *      1. Owed token amount added to storage mapping
     *
     * @param  owedTo     Address that tokens are owed to.
     * @param  tokenOwed  Token address being owed.
     * @param  owedAmount Amount of tokens owed.
     */
    function _storeTokensOwed(address owedTo, address tokenOwed, uint256 owedAmount) internal {
        bytes32 tokensOwedKey = EfficientHash.efficientHash(
            LIQUIDITY_OWED,
            EfficientHash.efficientHash(bytes32(uint256(uint160(owedTo))), bytes32(uint256(uint160(tokenOwed))))
        );
        unchecked {
            uint256 overflowCheck = Storage.appStorage().tokensOwed[tokensOwedKey] += owedAmount;
            if (overflowCheck < owedAmount) {
                revert LBAMM__Overflow();
            }
        }
    }

    /**
     * @dev Stores hook fees using token-specific or hook-managed storage keys.
     *
     * @dev Throws when addition would cause overflow.
     *
     *      Determines storage key based on whether hook manages its own fees. Uses nested efficient
     *      hashes for hook-managed fees or simple hash for token-managed fees. Safely accumulates
     *      fee amounts with overflow protection.
     *
     *      <h4>Postconditions:</h4>
     *      1. Hook fee amount added to appropriate storage mapping
     *      2. Storage key determined by fee management configuration
     *      3. Overflow protection validated
     *      4. tokensOwed mapping key calculated using efficient hash of addresses
     *      5. Hook-managed vs token-managed storage differentiation applied
     *
     * @param  tokenFor         Token the fee is associated with.
     * @param  tokenFee         Token being used to pay the fee.
     * @param  tokenForSettings Token configuration including fee management flags.
     * @param  feeAmount        Amount of fee tokens to store.
     */
    function _storeHookFees(
        address tokenFor,
        address tokenFee,
        TokenSettings memory tokenForSettings,
        uint256 feeAmount
    ) internal {
        bytes32 hookFeeKey;
        if (_isFlagSet(tokenForSettings.packedSettings, TOKEN_SETTINGS_HOOK_MANAGES_FEES_FLAG)) {
            hookFeeKey = EfficientHash.efficientHash(
                bytes32(uint256(uint160(tokenForSettings.tokenHook))),
                EfficientHash.efficientHash(bytes32(uint256(uint160(tokenFor))), bytes32(uint256(uint160(tokenFee))))
            );
        } else {
            hookFeeKey = EfficientHash.efficientHash(
                TOKEN_MANAGED_HOOK_FEE,
                EfficientHash.efficientHash(bytes32(uint256(uint160(tokenFor))), bytes32(uint256(uint160(tokenFee))))
            );
        }
        unchecked {
            uint256 overflowCheck = Storage.appStorage().tokensOwed[hookFeeKey] += feeAmount;
            if (overflowCheck < feeAmount) {
                revert LBAMM__Overflow();
            }
        }
    }

    /**
     * @dev Stores hook fees for a liquidity or pool hook.
     *
     * @dev Throws when addition would cause overflow.
     *
     *      <h4>Postconditions:</h4>
     *      1. Hook fee amount added to storage mapping
     *      2. Overflow protection validated
     *      3. tokensOwed mapping key calculated using efficient hash of addresses
     *
     * @param  hook       Address of the hook that the fees are for.
     * @param  tokenFor   Token the fee is associated with.
     * @param  feeAmount  Amount of fee tokens to store.
     */
    function _storeNonTokenHookFees(
        address hook,
        address tokenFor,
        uint256 feeAmount
    ) internal {
        bytes32 hookFeeKey = EfficientHash.efficientHash(
            bytes32(uint256(uint160(hook))),
            EfficientHash.efficientHash(bytes32(uint256(uint160(tokenFor))), bytes32(uint256(uint160(tokenFor))))
        );
        unchecked {
            uint256 overflowCheck = Storage.appStorage().tokensOwed[hookFeeKey] += feeAmount;
            if (overflowCheck < feeAmount) {
                revert LBAMM__Overflow();
            }
        }
    }

    /**
     * @dev Transfers all tokens owed to an address and clears the debt.
     *
     * @dev Throws when token transfer fails.
     *
     *      Retrieves the total amount owed to the specified address for the given token using efficient
     *      hash-based storage lookup. If any amount is owed, clears the debt record, transfers the full
     *      owed amount to the recipient, and emits a TokensClaimed event for tracking.
     *
     *      <h4>Postconditions:</h4>
     *      1. Debt record cleared in storage mapping for the address-token pair
     *      2. Full owed amount transferred to recipient if any debt existed
     *      3. TokensClaimed event emitted with transfer details
     *
     * @param  owedTo    Address receiving the owed tokens.
     * @param  tokenOwed Token address being transferred.
     */
    function _transferTokensOwed(address owedTo, address tokenOwed) internal {
        bytes32 tokensOwedKey = EfficientHash.efficientHash(
            LIQUIDITY_OWED,
            EfficientHash.efficientHash(bytes32(uint256(uint160(owedTo))), bytes32(uint256(uint160(tokenOwed))))
        );

        uint256 amountBefore = Storage.appStorage().tokensOwed[tokensOwedKey];
        if (amountBefore > 0) {
            Storage.appStorage().tokensOwed[tokensOwedKey] = 0;
            bool isError = SafeERC20.safeTransfer(tokenOwed, owedTo, amountBefore);
            if (isError) {
                revert LBAMM__TokenOwedTransferFailed();
            }
            emit TokensClaimed(owedTo, tokenOwed, amountBefore);
        }
    }

    /**
     * @dev Transfers hook fees by token association with underflow protection.
     *
     * @dev Throws when insufficient fees available causing underflow.
     *
     *      Reduces stored fee amount and transfers tokens to recipient with underflow validation to
     *      ensure sufficient fees were available.
     *
     *      <h4>Postconditions:</h4>
     *      1. Fee amount deducted from storage
     *      2. Tokens transferred to recipient
     *
     * @param  tokenFor  Token the fee is associated with.
     * @param  tokenFee  Token being transferred as fee payment.
     * @param  recipient Address receiving the fee tokens.
     * @param  amount    Amount of fee tokens to transfer.
     */
    function _transferHookFeesByToken(address tokenFor, address tokenFee, address recipient, uint256 amount) internal {
        bytes32 tokensOwedKey = EfficientHash.efficientHash(
            TOKEN_MANAGED_HOOK_FEE,
            EfficientHash.efficientHash(bytes32(uint256(uint160(tokenFor))), bytes32(uint256(uint160(tokenFee))))
        );
        unchecked {
            uint256 amountBefore = Storage.appStorage().tokensOwed[tokensOwedKey];
            uint256 underflowCheck = Storage.appStorage().tokensOwed[tokensOwedKey] -= amount;
            if (amountBefore < underflowCheck) {
                revert LBAMM__Underflow();
            }
            bool isError = SafeERC20.safeTransfer(tokenFee, recipient, amount);
            if (isError) {
                revert LBAMM__TransferHookFeeTransferFailed();
            }
            emit TokensClaimed(recipient, tokenFee, amount);
        }
    }

    /**
     * @dev Transfers hook fees by hook contract association.
     *
     * @dev Throws when insufficient fees available causing underflow.
     *
     *      Reduces stored fee amount for hook-managed fees and transfers tokens to recipient with
     *      underflow validation to ensure sufficient fees were available.
     *
     *      <h4>Postconditions:</h4>
     *      1. Hook-managed fee amount deducted from storage
     *      2. Tokens transferred to recipient
     *
     * @param  hook      Hook contract address managing the fees.
     * @param  tokenFor  Token the fee is associated with.
     * @param  tokenFee  Token being transferred as fee payment.
     * @param  recipient Address receiving the fee tokens.
     * @param  amount    Amount of fee tokens to transfer.
     */
    function _transferHookFeesByHook(
        address hook,
        address tokenFor,
        address tokenFee,
        address recipient,
        uint256 amount
    ) internal {
        bytes32 hookFeeKey = EfficientHash.efficientHash(
            bytes32(uint256(uint160(hook))),
            EfficientHash.efficientHash(bytes32(uint256(uint160(tokenFor))), bytes32(uint256(uint160(tokenFee))))
        );
        unchecked {
            uint256 amountBefore = Storage.appStorage().tokensOwed[hookFeeKey];
            uint256 underflowCheck = Storage.appStorage().tokensOwed[hookFeeKey] -= amount;
            if (amountBefore < underflowCheck) {
                revert LBAMM__Underflow();
            }
            bool isError = SafeERC20.safeTransfer(tokenFee, recipient, amount);
            if (isError) {
                revert LBAMM__TransferHookFeeTransferFailed();
            }
            emit TokensClaimed(recipient, tokenFee, amount);
        }
    }

    /**
     * @dev Transfers hook fees by hook contract association.
     *
     * @dev Throws when insufficient fees available causing underflow.
     *
     *      Reduces stored fee amount for hook-managed fees and transfers tokens to recipient with
     *      underflow validation to ensure sufficient fees were available.
     *
     *      <h4>Postconditions:</h4>
     *      1. Hook-managed fee amount deducted from storage
     *      2. Tokens transferred to recipient
     *
     * @param  hook      Hook contract address managing the fees.
     * @param  tokenFor  Token the fee is associated with.
     * @param  tokenFee  Token being transferred as fee payment.
     * @param  recipient Address receiving the fee tokens.
     * @param  amount    Amount of fee tokens to transfer.
     */
    function _queueTransferHookFeesByHook(
        address hook,
        address tokenFor,
        address tokenFee,
        address recipient,
        uint256 amount
    ) internal {
        unchecked {
            uint256 queueSlot = uint256(DIAMOND_STORAGE_QUEUED_FEE_COLLECT);
            uint256 queueIndex = _getTstorish(queueSlot);
            _setTstorish(queueSlot, queueIndex + 1);
            uint256 indexSlot = queueSlot + 1 + 5 * queueIndex;
            _setTstorish(indexSlot, uint256(uint160(hook)));
            _setTstorish(indexSlot + 1, uint256(uint160(tokenFor)));
            _setTstorish(indexSlot + 2, uint256(uint160(tokenFee)));
            _setTstorish(indexSlot + 3, uint256(uint160(recipient)));
            _setTstorish(indexSlot + 4, amount);
        }
    }

    function _queuedHookFeesByHookTransfers() internal view returns (uint256 queueLength) {
        queueLength = _getTstorish(uint256(DIAMOND_STORAGE_QUEUED_FEE_COLLECT));
    }

    function _executeQueuedHookFeesByHookTransfers() internal {
        unchecked {
            uint256 queueSlot = uint256(DIAMOND_STORAGE_QUEUED_FEE_COLLECT);
            uint256 queueLength = _getTstorish(queueSlot);
            if (queueLength == 0) return;

            _setTstorish(queueSlot, 0);
            _setReentrancyFlags(NO_FLAGS);

            for (uint256 queueIndex = 0; queueIndex < queueLength; ++queueIndex) {
                uint256 indexSlot = queueSlot + 1 + 5 * queueIndex;

                _transferHookFeesByHook(
                    address(uint160(_getTstorish(indexSlot))),
                    address(uint160(_getTstorish(indexSlot + 1))),
                    address(uint160(_getTstorish(indexSlot + 2))),
                    address(uint160(_getTstorish(indexSlot + 3))),
                    _getTstorish(indexSlot + 4)
                );
            }
        }
    }

    /**
     * @dev Accumulates protocol fees.
     *
     * @dev Throws when addition would cause overflow.
     *
     *      Safely adds protocol fee amount to stored totals with overflow protection and emits
     *      ProtocolFeeTaken event for fee tracking.
     *
     *      <h4>Postconditions:</h4>
     *      1. Protocol fee amount added to storage
     *      2. ProtocolFeeTaken event emitted
     *
     * @param  token  Token address for the protocol fees.
     * @param  amount Amount of protocol fees to store.
     */
    function _storeProtocolFees(address token, uint256 amount) internal {
        unchecked {
            uint256 overflowCheck = Storage.appStorage().protocolFees[token] += amount;
            if (overflowCheck < amount) {
                revert LBAMM__Overflow();
            }
            emit ProtocolFeeTaken(token, amount);
        }
    }

    /**
     * @dev Deposits wrapped native tokens and refunds excess native value.
     *
     * @dev Throws when insufficient native value sent.
     *      Throws when excess refund transfer fails.
     *
     *      Validates sufficient native value was sent, deposits required amount into wrapped native
     *      contract, and refunds any excess native value to the executor.
     *
     *      <h4>Postconditions:</h4>
     *      1. Required amount deposited into wrapped native contract
     *      2. Excess native value refunded to executor if applicable
     *
     * @param  executor  Address to receive any excess native value refund.
     * @param  amountIn  Required amount to deposit as wrapped native tokens.
     */
    function _depositWrappedNativeAndRefundExcess(address executor, uint256 amountIn) internal {
        if (msg.value < amountIn) {
            revert LBAMM__InsufficientValue();
        } else if (msg.value > amountIn) {
            unchecked {
                //refund excess
                (bool success,) = executor.call{value: msg.value - amountIn}("");
                if (!success) {
                    revert LBAMM__RefundFailed();
                }
            }
        }
        wrappedNative.deposit{value: amountIn}();
    }

    ///////////////////////////////////////////////////////
    //                   FLASH LOAN                      //
    ///////////////////////////////////////////////////////

    /**
     * @dev Executes a flash loan.
     *
     * @dev Throws when flash loans are disabled.
     *      Throws when token transfer fails.
     *      Throws when callback execution fails.
     *      Throws when insufficient tokens returned after callback.
     *
     *      Calculates fees using token hooks or default rates, transfers loan amount to executor,
     *      executes callback, validates return amounts including surplus handling, and distributes
     *      fees between hook fees and protocol fees.
     *
     *      <h4>Postconditions:</h4>
     *      1. Loan amount transferred to executor
     *      2. Flashloan callback executed on executor contract
     *      3. Required amounts collected back from executor
     *      4. Surplus amounts added to fees or stored as protocol fees
     *      5. Hook fees and protocol fees stored appropriately
     *      6. Flashloan event emitted with operation details
     *
     * @param  flashloanRequest Request parameters including amounts and executor.
     */
    function _flashLoan(
        FlashloanRequest calldata flashloanRequest
    ) internal {
        if (Storage.appStorage().flashLoanBPS > MAX_BPS) {
            revert LBAMM__FlashloansDisabled();
        }

        TokenSettings memory tokenSettings = Storage.appStorage().tokenSettings[flashloanRequest.loanToken];
        (address feeToken, uint256 tokenFeeAmount) = _executeTokenFlashloanHooks(flashloanRequest, tokenSettings);

        uint256 feeAmount;
        if (tokenFeeAmount == 0) {
            feeAmount = FullMath.mulDivRoundingUp(flashloanRequest.loanAmount, Storage.appStorage().flashLoanBPS, MAX_BPS);
        } else {
            feeAmount = tokenFeeAmount + FullMath.mulDivRoundingUp(tokenFeeAmount, Storage.appStorage().flashLoanBPS, MAX_BPS);
        }
        if (feeToken == address(0)) {
            feeToken = flashloanRequest.loanToken;
        }

        uint256 requiredTokenBalanceAfter;
        uint256 requiredFeeTokenBalanceAfter;
        if (feeToken == flashloanRequest.loanToken) {
            requiredTokenBalanceAfter = IERC20(feeToken).balanceOf(address(this)) + feeAmount;
        } else {
            requiredTokenBalanceAfter = IERC20(flashloanRequest.loanToken).balanceOf(address(this));
            requiredFeeTokenBalanceAfter = IERC20(feeToken).balanceOf(address(this)) + feeAmount;
        }

        bool transferError = SafeERC20.safeTransfer(flashloanRequest.loanToken, flashloanRequest.executor, flashloanRequest.loanAmount);
        if (transferError) {
            revert LBAMM__TokenOutTransferFailed();
        }
        bytes4 magicValue = ILimitBreakAMMFlashloanCallback(flashloanRequest.executor).flashloanCallback(
            msg.sender,
            flashloanRequest.loanToken,
            flashloanRequest.loanAmount,
            feeToken,
            feeAmount,
            flashloanRequest.executorData
        );

        if (magicValue != ILimitBreakAMMFlashloanCallback.flashloanCallback.selector) {
            revert LBAMM__FlashloanExecutionFailed();
        }

        if (feeToken == flashloanRequest.loanToken) {
            uint256 tokenBalanceAfter = IERC20(feeToken).balanceOf(address(this));
            if (tokenBalanceAfter > requiredTokenBalanceAfter) {
                uint256 returnSurplus;
                unchecked {
                    returnSurplus = tokenBalanceAfter - requiredTokenBalanceAfter;
                }
                feeAmount = feeAmount + returnSurplus;
            } else if (tokenBalanceAfter < requiredTokenBalanceAfter) {
                unchecked {
                    _collectToken(flashloanRequest.executor, feeToken, requiredTokenBalanceAfter - tokenBalanceAfter);
                }
            }
        } else {
            uint256 tokenBalanceAfter = IERC20(flashloanRequest.loanToken).balanceOf(address(this));
            if (tokenBalanceAfter > requiredTokenBalanceAfter) {
                unchecked {
                    _storeProtocolFees(flashloanRequest.loanToken, tokenBalanceAfter - requiredTokenBalanceAfter);
                }
            } else if (tokenBalanceAfter < requiredTokenBalanceAfter) {
                unchecked {
                    _collectToken(flashloanRequest.executor, flashloanRequest.loanToken, requiredTokenBalanceAfter - tokenBalanceAfter);
                }
            }

            tokenBalanceAfter = IERC20(feeToken).balanceOf(address(this));
            if (tokenBalanceAfter > requiredFeeTokenBalanceAfter) {
                uint256 returnSurplus;
                unchecked {
                    returnSurplus = tokenBalanceAfter - requiredFeeTokenBalanceAfter;
                }
                feeAmount = feeAmount + returnSurplus;
            } else if (tokenBalanceAfter < requiredFeeTokenBalanceAfter) {
                unchecked {
                    _collectToken(flashloanRequest.executor, feeToken, requiredFeeTokenBalanceAfter - tokenBalanceAfter);
                }
            }
        }

        unchecked {
            if (tokenFeeAmount > 0) {
                _storeHookFees(flashloanRequest.loanToken, feeToken, tokenSettings, tokenFeeAmount);
                feeAmount -= tokenFeeAmount;
            }
            _storeProtocolFees(feeToken, feeAmount);
        }

        emit Flashloan(msg.sender, flashloanRequest.executor, flashloanRequest.loanToken, flashloanRequest.loanAmount, feeToken, feeAmount);
    }

    /**
     * @dev Executes token hook validations for flash loan operations.
     *
     * @dev Throws when fee token returned as zero address.
     *      Throws when fee token validation fails for cross-token fees.
     *
     *      Executes beforeFlashloan hook if enabled for the loan token, validates fee token if
     *      different from loan token by calling fee validation hook, and returns fee token and
     *      amount determined by hooks.
     *
     *      <h4>Postconditions:</h4>
     *      1. Before flashloan hook executed if enabled
     *      2. Fee token validation completed for cross-token fees
     *      3. Fee token and amount determined by hook logic
     *
     * @param  flashloanRequest Request parameters including hook data.
     * @param  tokenSettings    Loan token configuration including hook settings.
     * @return feeToken         Token address to be used for fee payment.
     * @return tokenFeeAmount   Fee amount determined by token hook.
     */
    function _executeTokenFlashloanHooks(
        FlashloanRequest calldata flashloanRequest,
        TokenSettings memory tokenSettings
    ) internal returns (address feeToken, uint256 tokenFeeAmount) {
        if (_isFlagSet(tokenSettings.packedSettings, TOKEN_SETTINGS_FLASHLOANS_FLAG)) {
            (feeToken, tokenFeeAmount) = ILimitBreakAMMTokenHook(tokenSettings.tokenHook).beforeFlashloan(
                msg.sender,
                flashloanRequest.loanToken,
                flashloanRequest.loanAmount,
                flashloanRequest.executor,
                flashloanRequest.tokenHookData
            );
            if (feeToken == address(0)) {
                revert LBAMM__FlashloanFeeTokenCannotBeAddressZero();
            }
            if (feeToken != flashloanRequest.loanToken) {
                TokenSettings memory feeTokenSettings = Storage.appStorage().tokenSettings[feeToken];
                if (_isFlagSet(feeTokenSettings.packedSettings, TOKEN_SETTINGS_FLASHLOANS_VALIDATE_FEE_FLAG)) {
                    bool feeAllowed = ILimitBreakAMMTokenHook(feeTokenSettings.tokenHook).validateFlashloanFee(
                        msg.sender,
                        flashloanRequest.loanToken,
                        flashloanRequest.loanAmount,
                        feeToken,
                        tokenFeeAmount,
                        flashloanRequest.executor,
                        flashloanRequest.feeTokenHookData
                    );
                    if (!feeAllowed) {
                        revert LBAMM__FeeTokenNotAllowedForFlashloan();
                    }
                }
            }
        }
    }

    ///////////////////////////////////////////////////////
    //                   PROTOCOL                        //
    ///////////////////////////////////////////////////////

    /**
     * @dev Sets the protocol fee structure for all operations in the AMM.
     *
     * @dev Throws when any fee component exceeds the maximum allowed fee percentage.
     *
     *      The protocol fee structure defines how fees are collected across different operations including
     *      LP fees, exchange fees, and fees-on-top. These fees fund protocol operations and provide revenue
     *      for protocol stakeholders.
     *
     *      <h4>Postconditions:</h4>
     *      1. Protocol fee structure has been updated in storage.
     *      2. ProtocolFeesSet event has been emitted with the new fee structure.
     *
     * @param  protocolFeeStructure The new fee structure containing LP, exchange, and fee-on-top rates.
     */
    function _setProtocolFees(ProtocolFeeStructure memory protocolFeeStructure) internal {
        if (protocolFeeStructure.lpFeeBPS > MAX_BPS) revert LBAMM__FeeAmountExceedsMaxFee();
        if (protocolFeeStructure.exchangeFeeBPS > MAX_BPS) revert LBAMM__FeeAmountExceedsMaxFee();
        if (protocolFeeStructure.feeOnTopBPS > MAX_BPS) revert LBAMM__FeeAmountExceedsMaxFee();

        Storage.appStorage().protocolFeeStructure = protocolFeeStructure;

        emit ProtocolFeesSet(
            protocolFeeStructure.lpFeeBPS, protocolFeeStructure.exchangeFeeBPS, protocolFeeStructure.feeOnTopBPS
        );
    }

    /**
     * @dev Sets the hop fee for a specific token used in multi-hop swaps.
     *
     * @dev Throws when the hop fee exceeds the maximum allowed fee percentage.
     *
     *      Hop fees are collected when tokens are used as intermediate tokens in multi-hop swap routes.
     *      This provides a mechanism for tokens to earn fees from routing activity.
     *
     *      <h4>Postconditions:</h4>
     *      1. Token's hop fee has been updated in storage.
     *      2. TokenFeeSet event has been emitted with the new fee rate.
     *
     * @param  token     The token address for which to set the hop fee.
     * @param  hopFeeBPS The hop fee rate in basis points.
     */
    function _setTokenFee(address token, uint16 hopFeeBPS) internal {
        if (hopFeeBPS >= MAX_BPS) revert LBAMM__FeeAmountExceedsMaxFee();

        Storage.appStorage().tokenSettings[token].hopFeeBPS = hopFeeBPS;

        emit TokenFeeSet(token, hopFeeBPS);
    }

    ///////////////////////////////////////////////////////
    //                   ARITHMETIC                      //
    ///////////////////////////////////////////////////////

    /**
     * @dev  Adds two uint256 values while validating that the sum does not overflow a uint128.
     * 
     * @param a  First value to add.
     * @param b  Second value to add.
     */
    function _safeIncrementUint128(uint256 a, uint256 b) internal pure returns (uint128 sum) {
        assembly ("memory-safe") {
            sum := add(a, b)
            if or(gt(shr(128, sum), 0), lt(sum, a)) {
                mstore(0x00, 0x99EFB929) //SafeCast__Uint128Overflow()
                revert(0x1C, 0x04)
            }
        }
    }

    /**
     * @dev  Subtracts a uint256 value from another uint256 value while validating that the difference 
     *       does not underflow.
     * 
     * @param a  Value to subtract `b` from.
     * @param b  Value to subtract from `a.
     */
    function _safeDecrementUint128(uint256 a, uint256 b) internal pure returns (uint128 difference) {
        assembly ("memory-safe") {
            difference := sub(a, b)
            if gt(difference, a) {
                mstore(0x00, 0x99EFB929) //SafeCast__Uint128Overflow()
                revert(0x1C, 0x04)
            }
        }
    }

    /**
     * @notice Calculates adjusted length for bytes array data accounting for ABI encoding alignment.
     *
     * @dev    Throws when bytes length exceeds maximum uint32 value.
     *
     *         Adds the provided bytes length to the current data length while accounting for ABI
     *         encoding's 32-byte alignment requirements. This ensures accurate calculation of
     *         total calldata length.
     *
     * @param  currentDataLength Current accumulated data length.
     * @param  bytesLength       Length of the bytes array to add.
     * @return totalLength       Updated total length with proper alignment adjustment.
     */
    function _addAdjustedBytesLength(
        uint256 currentDataLength, 
        uint256 bytesLength
    ) internal pure returns (uint256 totalLength) {
        if (bytesLength > type(uint32).max) {
            revert LBAMM__BytesLengthExceedsMax();
        }
        unchecked {
            totalLength = currentDataLength + ((bytesLength + 31) & ~uint256(31));
        }
    }
}